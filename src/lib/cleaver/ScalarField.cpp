//-------------------------------------------------------------------
//-------------------------------------------------------------------
//
// Cleaver - A MultiMaterial Tetrahedral Mesher
// -- 3D Float Point Data Field
//
//  Author: Jonathan Bronson (bronson@sci.utah.edu)
//
//-------------------------------------------------------------------
//-------------------------------------------------------------------
//
//  Copyright (C) 2011, 2012, Jonathan Bronson
//  Scientific Computing & Imaging Institute
//  University of Utah
//
//  Permission is  hereby  granted, free  of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files  ( the "Software" ),  to  deal in  the  Software without
//  restriction, including  without limitation the rights to  use,
//  copy, modify,  merge, publish, distribute, sublicense,  and/or
//  sell copies of the Software, and to permit persons to whom the
//  Software is  furnished  to do  so,  subject  to  the following
//  conditions:
//
//  The above  copyright notice  and  this permission notice shall
//  be included  in  all copies  or  substantial  portions  of the
//  Software.
//
//  THE SOFTWARE IS  PROVIDED  "AS IS",  WITHOUT  WARRANTY  OF ANY
//  KIND,  EXPRESS OR IMPLIED, INCLUDING  BUT NOT  LIMITED  TO THE
//  WARRANTIES   OF  MERCHANTABILITY,  FITNESS  FOR  A  PARTICULAR
//  PURPOSE AND NONINFRINGEMENT. IN NO EVENT  SHALL THE AUTHORS OR
//  COPYRIGHT HOLDERS  BE  LIABLE FOR  ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
//  USE OR OTHER DEALINGS IN THE SOFTWARE.
//-------------------------------------------------------------------
//-------------------------------------------------------------------

#include <math.h>
#include "ScalarField.h"
#include "vec3.h"


namespace cleaver
{

template <typename T>
cleaver::CenteringType ScalarField<T>::DefaultCenteringType = cleaver::CellCentered;

template <typename T>
ScalarField<T>::ScalarField(T *data, int w, int h, int d)
    : m_w(w), m_h(h), m_d(d), m_data(data)
{
    // default to data bounds
    m_scale = vec3(vec3::unitX.x, vec3::unitY.y, vec3::unitZ.z);
    m_scaleInv = m_scale;

    m_centeringType = ScalarField<T>::DefaultCenteringType;
    m_bounds = dataBounds();
}

template <typename T>
ScalarField<T>::~ScalarField()
{
    // no memory cleanup
}

template <typename T>
double ScalarField<T>::valueAt(double x, double y, double z) const
{
    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered){
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    int i0 = (int)floor(x);   int i1 = i0+1;
    int j0 = (int)floor(y);   int j1 = j0+1;
    int k0 = (int)floor(z);   int k1 = k0+1;


    if(m_centeringType == CellCentered)
    {
        i0 = clamp(i0, 0, m_w-1);
        j0 = clamp(j0, 0, m_h-1);
        k0 = clamp(k0, 0, m_d-1);

        i1 = clamp(i1, 0, m_w-1);
        j1 = clamp(j1, 0, m_h-1);
        k1 = clamp(k1, 0, m_d-1);
    }
    else if(m_centeringType == NodeCentered)
    {
        i0 = clamp(i0, 0, m_w-2);
        j0 = clamp(j0, 0, m_h-2);
        k0 = clamp(k0, 0, m_d-2);

        i1 = clamp(i1, 0, m_w-2);
        j1 = clamp(j1, 0, m_h-2);
        k1 = clamp(k1, 0, m_d-2);
    }


    double C000 = m_data[i0 + j0*m_w + k0*m_w*m_h];
    double C001 = m_data[i0 + j0*m_w + k1*m_w*m_h];
    double C010 = m_data[i0 + j1*m_w + k0*m_w*m_h];
    double C011 = m_data[i0 + j1*m_w + k1*m_w*m_h];
    double C100 = m_data[i1 + j0*m_w + k0*m_w*m_h];
    double C101 = m_data[i1 + j0*m_w + k1*m_w*m_h];
    double C110 = m_data[i1 + j1*m_w + k0*m_w*m_h];
    double C111 = m_data[i1 + j1*m_w + k1*m_w*m_h];

    return double((1-t)*(1-u)*(1-v)*C000 + (1-t)*(1-u)*(v)*C001 +
                 (1-t)*  (u)*(1-v)*C010 + (1-t)*  (u)*(v)*C011 +
                   (t)*(1-u)*(1-v)*C100 +   (t)*(1-u)*(v)*C101 +
                   (t)*  (u)*(1-v)*C110 +   (t)*  (u)*(v)*C111);
}

template <typename T>
double ScalarField<T>::valueAt(const vec3 &x) const
{
    return valueAt((double)x.x,(double)x.y,(double)x.z);
}


double cubicInterpolate (double p[4], double x)
{
    return p[1] + 0.5 * x*(p[2] - p[0] + x*(2.0*p[0] - 5.0*p[1] + 4.0*p[2] - p[3] + x*(3.0*(p[1] - p[2]) + p[3] - p[0])));
}

double bicubicInterpolate (double p[4][4], double x, double y) {
    double arr[4];
    arr[0] = cubicInterpolate(p[0], y);
    arr[1] = cubicInterpolate(p[1], y);
    arr[2] = cubicInterpolate(p[2], y);
    arr[3] = cubicInterpolate(p[3], y);
    return cubicInterpolate(arr, x);
}

double tricubicInterpolate (double p[4][4][4], double x, double y, double z) {
    double arr[4];
    arr[0] = bicubicInterpolate(p[0], y, z);
    arr[1] = bicubicInterpolate(p[1], y, z);
    arr[2] = bicubicInterpolate(p[2], y, z);
    arr[3] = bicubicInterpolate(p[3], y, z);
    return cubicInterpolate(arr, x);
}

double cubicGradientInterpolate (double p[4], double x)
{
    return 0.5*(p[2] - p[0]) + 2.0*0.5*x*(2.0*p[0] - 5.0*p[1] + 4.0*p[2] - p[3] + 3.0*0.5*x*(3.0*(p[1] - p[2]) + p[3] - p[0]));
}

double bicubicGradientInterpolate (double p[4][4], double x, double y) {
    double arr[4];
    arr[0] = cubicGradientInterpolate(p[0], y);
    arr[1] = cubicGradientInterpolate(p[1], y);
    arr[2] = cubicGradientInterpolate(p[2], y);
    arr[3] = cubicGradientInterpolate(p[3], y);
    return cubicGradientInterpolate(arr, x);
}

double tricubicGradientInterpolate (double p[4][4][4], double x, double y, double z) {
    double arr[4];
    arr[0] = bicubicGradientInterpolate(p[0], y, z);
    arr[1] = bicubicGradientInterpolate(p[1], y, z);
    arr[2] = bicubicGradientInterpolate(p[2], y, z);
    arr[3] = bicubicGradientInterpolate(p[3], y, z);
    return cubicGradientInterpolate(arr, x);
}

template <typename T>
double ScalarField<T>::tricubicValueAt(const vec3 &x) const
{
    return tricubicValueAt(x.x, x.y, x.z);
}

template <typename T>
double ScalarField<T>::tricubicValueAt(double x, double y, double z) const
{
    double p[4][4][4];

    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered)
    {
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    // Get Interpolation Offset
    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    // Get Coordinate Offset
    int x0 = (int)floor(x);
    int y0 = (int)floor(y);
    int z0 = (int)floor(z);

    // Determine Clamping
    vec3 clamp_range;
    if(m_centeringType == CellCentered)
        clamp_range = vec3(m_w-1, m_h-1, m_d-1);
    else if(m_centeringType == NodeCentered)
        clamp_range = vec3(m_w-2, m_h-2, m_d-2);

    // Grab All 64 Values
    for(int k=0; k < 4; k++){
        for(int j=0; j < 4; j++){
            for(int i=0; i < 4; i++){

                // adjust to match grid
                int ii = x0 + i - 1;
                int jj = y0 + j - 1;
                int kk = z0 + k - 1;

                // then clamp to be in bounds
                ii = clamp(ii, 0, (int)clamp_range.x);
                jj = clamp(jj, 0, (int)clamp_range.y);
                kk = clamp(kk, 0, (int)clamp_range.z);

                // then query value
                p[i][j][k] = m_data[ii + jj*m_w + kk*m_w*m_h];
            }
        }
    }

    double value = tricubicInterpolate(p, t, u, v);

    return value;
}

template <typename T>
vec3 ScalarField<T>::tricubicGradientAt(const vec3 &x) const
{
    return tricubicGradientAt(x.x, x.y, x.z);
}

template <typename T>
vec3 ScalarField<T>::tricubicGradientAt(double x, double y, double z) const
{
    vec3 gradient;

    return gradient;
}

template <typename T>
double ScalarField<T>::cachedTricubicValueAt(const vec3 &x) const
{
        return cachedTricubicValueAt(x.x, x.y, x.z);
}

template <typename T>
double ScalarField<T>::cachedTricubicValueAt(double x, double y, double z) const
{
    static double a000, a001, a002, a003,    a010, a011, a012, a013,    a020, a021, a022, a023,    a030, a031, a032, a033;
    static double a100, a101, a102, a103,    a110, a111, a112, a113,    a120, a121, a122, a123,    a130, a131, a132, a133;
    static double a200, a201, a202, a203,    a210, a211, a212, a213,    a220, a221, a222, a223,    a230, a231, a232, a233;
    static double a300, a301, a302, a303,    a310, a311, a312, a313,    a320, a321, a322, a323,    a330, a331, a332, a333;

    static double p000, p001, p002, p003,    p010, p011, p012, p013,    p020, p021, p022, p023,    p030, p031, p032, p033;
    static double p100, p101, p102, p103,    p110, p111, p112, p113,    p120, p121, p122, p123,    p130, p131, p132, p133;
    static double p200, p201, p202, p203,    p210, p211, p212, p213,    p220, p221, p222, p223,    p230, p231, p232, p233;
    static double p300, p301, p302, p303,    p310, p311, p312, p313,    p320, p321, p322, p323,    p330, p331, p332, p333;

    static double a[4][4][4] = {0};
    double p[4][4][4] = {0};

    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered)
    {
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    // Get Interpolation Offset
    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    // Get Coordinate Offset
    int x0 = (int)floor(x);
    int y0 = (int)floor(y);
    int z0 = (int)floor(z);

    // Determine Clamping
    vec3 clamp_range;
    if(m_centeringType == CellCentered)
        clamp_range = vec3(m_w-1, m_h-1, m_d-1);
    else if(m_centeringType == NodeCentered)
        clamp_range = vec3(m_w-2, m_h-2, m_d-2);

    // recalculate coefficients if in new cell than last call
    /*
    static int prev_int_x = 0;
    static int prev_int_y = 0;
    static int prev_int_z = 0;

    if(prev_int_x != int_x ||
       prev_int_y != int_y ||
       prev_int_z != int_z)
    {
        prev_int_x = int_x;
        prev_int_y = int_y;
        prev_int_z = int_z;

        // ....
    }*/

    // Grab All 64 Values
    for(int k=0; k < 4; k++){
        for(int j=0; j < 4; j++){
            for(int i=0; i < 4; i++){

                // adjust to match grid
                int ii = x0 + i - 1;
                int jj = y0 + j - 1;
                int kk = z0 + k - 1;

                // then clamp to be in bounds
                ii = clamp(ii, 0, (int)clamp_range.x);
                jj = clamp(jj, 0, (int)clamp_range.y);
                kk = clamp(kk, 0, (int)clamp_range.z);

                // then query value
                p[i][j][k] = m_data[ii + jj*m_w + kk*m_w*m_h];
            }
        }
    }

    p000 = p[0][0][0];
    p001 = p[0][0][1];
    p002 = p[0][0][2];
    p003 = p[0][0][3];
    p010 = p[0][1][0];
    p011 = p[0][1][1];
    p012 = p[0][1][2];
    p013 = p[0][1][3];
    p020 = p[0][2][0];
    p021 = p[0][2][1];
    p022 = p[0][2][2];
    p023 = p[0][2][3];
    p030 = p[0][3][0];
    p031 = p[0][3][1];
    p032 = p[0][3][2];
    p033 = p[0][3][3];
    p100 = p[1][0][0];
    p101 = p[1][0][1];
    p102 = p[1][0][2];
    p103 = p[1][0][3];
    p110 = p[1][1][0];
    p111 = p[1][1][1];
    p112 = p[1][1][2];
    p113 = p[1][1][3];
    p120 = p[1][2][0];
    p121 = p[1][2][1];
    p122 = p[1][2][2];
    p123 = p[1][2][3];
    p130 = p[1][3][0];
    p131 = p[1][3][1];
    p132 = p[1][3][2];
    p133 = p[1][3][3];
    p200 = p[2][0][0];
    p201 = p[2][0][1];
    p202 = p[2][0][2];
    p203 = p[2][0][3];
    p210 = p[2][1][0];
    p211 = p[2][1][1];
    p212 = p[2][1][2];
    p213 = p[2][1][3];
    p220 = p[2][2][0];
    p221 = p[2][2][1];
    p222 = p[2][2][2];
    p223 = p[2][2][3];
    p230 = p[2][3][0];
    p231 = p[2][3][1];
    p232 = p[2][3][2];
    p233 = p[2][3][3];
    p300 = p[3][0][0];
    p301 = p[3][0][1];
    p302 = p[3][0][2];
    p303 = p[3][0][3];
    p310 = p[3][1][0];
    p311 = p[3][1][1];
    p312 = p[3][1][2];
    p313 = p[3][1][3];
    p320 = p[3][2][0];
    p321 = p[3][2][1];
    p322 = p[3][2][2];
    p323 = p[3][2][3];
    p330 = p[3][3][0];
    p331 = p[3][3][1];
    p332 = p[3][3][2];
    p333 = p[3][3][3];

    // CForm[Coefficient[Collect[Coefficient[a, y, 0], z], z, 0]]
    // update coefficients (todo: make separate function)
    {
        a000 = p111;
        a001 = -p110/2. + p112/2.;
        a002 = p110 - (5*p111)/2. + 2*p112 - p113/2.;
        a003 = -p110/2. + (3*p111)/2. - (3*p112)/2. + p113/2.;
        a010 = -p101/2. + p121/2.;
        a011 = (p100/2. - p102/2.)/2. + (-p120/2. + p122/2.)/2.;
        a012 = (-p100 + (5*p101)/2. - 2*p102 + p103/2.)/2. + (p120 - (5*p121)/2. + 2*p122 - p123/2.)/2.;
        a013 = (p100/2. - (3*p101)/2. + (3*p102)/2. - p103/2.)/2. + (-p120/2. + (3*p121)/2. - (3*p122)/2. + p123/2.)/2.;
        a020 = p101 - (5*p111)/2. + 2*p121 - p131/2.;
        a021 = -p100/2. + p102/2. - (5*(-p110/2. + p112/2.))/2. + 2*(-p120/2. + p122/2.) + (p130/2. - p132/2.)/2.;
        a022 = p100 - (5*p101)/2. + 2*p102 - p103/2. - (5*(p110 - (5*p111)/2. + 2*p112 - p113/2.))/2. + 2*(p120 - (5*p121)/2. + 2*p122 - p123/2.) + (-p130 + (5*p131)/2. - 2*p132 + p133/2.)/2.;
        a023 = -p100/2. + (3*p101)/2. - (3*p102)/2. + p103/2. - (5*(-p110/2. + (3*p111)/2. - (3*p112)/2. + p113/2.))/2. + 2*(-p120/2. + (3*p121)/2. - (3*p122)/2. + p123/2.) + (p130/2. - (3*p131)/2. + (3*p132)/2. - p133/2.)/2.;
        a030 = -p101/2. + (3*p111)/2. - (3*p121)/2. + p131/2.;
        a031 = (p100/2. - p102/2.)/2. + (3*(-p110/2. + p112/2.))/2. - (3*(-p120/2. + p122/2.))/2. + (-p130/2. + p132/2.)/2.;
        a032 = (-p100 + (5*p101)/2. - 2*p102 + p103/2.)/2. + (3*(p110 - (5*p111)/2. + 2*p112 - p113/2.))/2. - (3*(p120 - (5*p121)/2. + 2*p122 - p123/2.))/2. + (p130 - (5*p131)/2. + 2*p132 - p133/2.)/2.;
        a033 = (p100/2. - (3*p101)/2. + (3*p102)/2. - p103/2.)/2. + (3*(-p110/2. + (3*p111)/2. - (3*p112)/2. + p113/2.))/2. - (3*(-p120/2. + (3*p121)/2. - (3*p122)/2. + p123/2.))/2. + (-p130/2. + (3*p131)/2. - (3*p132)/2. + p133/2.)/2.;
        a100 = -p011/2. + p211/2.;
        a101 = p010/4. - p012/4. - p210/4. + p212/4.;
        a102 = -p010/2. + (5*p011)/4. - p012 + p013/4. + p210/2. - (5*p211)/4. + p212 - p213/4.;
        a103 = p010/4. - (3*p011)/4. + (3*p012)/4. - p013/4. - p210/4. + (3*p211)/4. - (3*p212)/4. + p213/4.;
        a110 = p001/4. - p021/4. - p201/4. + p221/4.;
        a111 = -p000/8. + p002/8. + p020/8. - p022/8. + p200/8. - p202/8. - p220/8. + p222/8.;
        a112 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - p020/4. + (5*p021)/8. - p022/2. + p023/8. - p200/4. + (5*p201)/8. - p202/2. + p203/8. + p220/4. - (5*p221)/8. + p222/2. - p223/8.;
        a113 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + p020/8. - (3*p021)/8. + (3*p022)/8. - p023/8. + p200/8. - (3*p201)/8. + (3*p202)/8. - p203/8. - p220/8. + (3*p221)/8. - (3*p222)/8. + p223/8.;
        a120 = -p001/2. + (5*p011)/4. - p021 + p031/4. + p201/2. - (5*p211)/4. + p221 - p231/4.;
        a121 = p000/4. - p002/4. - (5*p010)/8. + (5*p012)/8. + p020/2. - p022/2. - p030/8. + p032/8. - p200/4. + p202/4. + (5*p210)/8. - (5*p212)/8. - p220/2. + p222/2. + p230/8. - p232/8.;
        a122 = -p000/2. + (5*p001)/4. - p002 + p003/4. + (5*p010)/4. - (25*p011)/8. + (5*p012)/2. - (5*p013)/8. - p020 + (5*p021)/2. - 2*p022 + p023/2. + p030/4. - (5*p031)/8. + p032/2. - p033/8. + p200/2. - (5*p201)/4. + p202 - p203/4. - (5*p210)/4. + (25*p211)/8. - (5*p212)/2. + (5*p213)/8. + p220 - (5*p221)/2. + 2*p222 - p223/2. - p230/4. + (5*p231)/8. - p232/2. + p233/8.;
        a123 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - (5*p010)/8. + (15*p011)/8. - (15*p012)/8. + (5*p013)/8. + p020/2. - (3*p021)/2. + (3*p022)/2. - p023/2. - p030/8. + (3*p031)/8. - (3*p032)/8. + p033/8. - p200/4. + (3*p201)/4. - (3*p202)/4. + p203/4. + (5*p210)/8. - (15*p211)/8. + (15*p212)/8. - (5*p213)/8. - p220/2. + (3*p221)/2. - (3*p222)/2. + p223/2. + p230/8. - (3*p231)/8. + (3*p232)/8. - p233/8.;
        a130 = p001/4. - (3*p011)/4. + (3*p021)/4. - p031/4. - p201/4. + (3*p211)/4. - (3*p221)/4. + p231/4.;
        a131 = -p000/8. + p002/8. + (3*p010)/8. - (3*p012)/8. - (3*p020)/8. + (3*p022)/8. + p030/8. - p032/8. + p200/8. - p202/8. - (3*p210)/8. + (3*p212)/8. + (3*p220)/8. - (3*p222)/8. - p230/8. + p232/8.;
        a132 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - (3*p010)/4. + (15*p011)/8. - (3*p012)/2. + (3*p013)/8. + (3*p020)/4. - (15*p021)/8. + (3*p022)/2. - (3*p023)/8. - p030/4. + (5*p031)/8. - p032/2. + p033/8. - p200/4. + (5*p201)/8. - p202/2. + p203/8. + (3*p210)/4. - (15*p211)/8. + (3*p212)/2. - (3*p213)/8. - (3*p220)/4. + (15*p221)/8. - (3*p222)/2. + (3*p223)/8. + p230/4. - (5*p231)/8. + p232/2. - p233/8.;
        a133 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + (3*p010)/8. - (9*p011)/8. + (9*p012)/8. - (3*p013)/8. - (3*p020)/8. + (9*p021)/8. - (9*p022)/8. + (3*p023)/8. + p030/8. - (3*p031)/8. + (3*p032)/8. - p033/8. + p200/8. - (3*p201)/8. + (3*p202)/8. - p203/8. - (3*p210)/8. + (9*p211)/8. - (9*p212)/8. + (3*p213)/8. + (3*p220)/8. - (9*p221)/8. + (9*p222)/8. - (3*p223)/8. - p230/8. + (3*p231)/8. - (3*p232)/8. + p233/8.;
        a200 = p011 - (5*p111)/2. + 2*p211 - p311/2.;
        a201 = -p010/2. + p012/2. + (5*p110)/4. - (5*p112)/4. - p210 + p212 + p310/4. - p312/4.;
        a202 = p010 - (5*p011)/2. + 2*p012 - p013/2. - (5*p110)/2. + (25*p111)/4. - 5*p112 + (5*p113)/4. + 2*p210 - 5*p211 + 4*p212 - p213 - p310/2. + (5*p311)/4. - p312 + p313/4.;
        a203 = -p010/2. + (3*p011)/2. - (3*p012)/2. + p013/2. + (5*p110)/4. - (15*p111)/4. + (15*p112)/4. - (5*p113)/4. - p210 + 3*p211 - 3*p212 + p213 + p310/4. - (3*p311)/4. + (3*p312)/4. - p313/4.;
        a210 = -p001/2. + p021/2. + (5*p101)/4. - (5*p121)/4. - p201 + p221 + p301/4. - p321/4.;
        a211 = p000/4. - p002/4. - p020/4. + p022/4. - (5*p100)/8. + (5*p102)/8. + (5*p120)/8. - (5*p122)/8. + p200/2. - p202/2. - p220/2. + p222/2. - p300/8. + p302/8. + p320/8. - p322/8.;
        a212 = -p000/2. + (5*p001)/4. - p002 + p003/4. + p020/2. - (5*p021)/4. + p022 - p023/4. + (5*p100)/4. - (25*p101)/8. + (5*p102)/2. - (5*p103)/8. - (5*p120)/4. + (25*p121)/8. - (5*p122)/2. + (5*p123)/8. - p200 + (5*p201)/2. - 2*p202 + p203/2. + p220 - (5*p221)/2. + 2*p222 - p223/2. + p300/4. - (5*p301)/8. + p302/2. - p303/8. - p320/4. + (5*p321)/8. - p322/2. + p323/8.;
        a213 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - p020/4. + (3*p021)/4. - (3*p022)/4. + p023/4. - (5*p100)/8. + (15*p101)/8. - (15*p102)/8. + (5*p103)/8. + (5*p120)/8. - (15*p121)/8. + (15*p122)/8. - (5*p123)/8. + p200/2. - (3*p201)/2. + (3*p202)/2. - p203/2. - p220/2. + (3*p221)/2. - (3*p222)/2. + p223/2. - p300/8. + (3*p301)/8. - (3*p302)/8. + p303/8. + p320/8. - (3*p321)/8. + (3*p322)/8. - p323/8.;
        a220 = p001 - (5*p011)/2. + 2*p021 - p031/2. - (5*p101)/2. + (25*p111)/4. - 5*p121 + (5*p131)/4. + 2*p201 - 5*p211 + 4*p221 - p231 - p301/2. + (5*p311)/4. - p321 + p331/4.;
        a221 = -p000/2. + p002/2. + (5*p010)/4. - (5*p012)/4. - p020 + p022 + p030/4. - p032/4. + (5*p100)/4. - (5*p102)/4. - (25*p110)/8. + (25*p112)/8. + (5*p120)/2. - (5*p122)/2. - (5*p130)/8. + (5*p132)/8. - p200 + p202 + (5*p210)/2. - (5*p212)/2. - 2*p220 + 2*p222 + p230/2. - p232/2. + p300/4. - p302/4. - (5*p310)/8. + (5*p312)/8. + p320/2. - p322/2. - p330/8. + p332/8.;
        a222 = p000 - (5*p001)/2. + 2*p002 - p003/2. - (5*p010)/2. + (25*p011)/4. - 5*p012 + (5*p013)/4. + 2*p020 - 5*p021 + 4*p022 - p023 - p030/2. + (5*p031)/4. - p032 + p033/4. - (5*p100)/2. + (25*p101)/4. - 5*p102 + (5*p103)/4. + (25*p110)/4. - (125*p111)/8. + (25*p112)/2. - (25*p113)/8. - 5*p120 + (25*p121)/2. - 10*p122 + (5*p123)/2. + (5*p130)/4. - (25*p131)/8. + (5*p132)/2. - (5*p133)/8. + 2*p200 - 5*p201 + 4*p202 - p203 - 5*p210 + (25*p211)/2. - 10*p212 + (5*p213)/2. + 4*p220 - 10*p221 + 8*p222 - 2*p223 - p230 + (5*p231)/2. - 2*p232 + p233/2. - p300/2. + (5*p301)/4. - p302 + p303/4. + (5*p310)/4. - (25*p311)/8. + (5*p312)/2. - (5*p313)/8. - p320 + (5*p321)/2. - 2*p322 + p323/2. + p330/4. - (5*p331)/8. + p332/2. - p333/8.;
        a223 = -p000/2. + (3*p001)/2. - (3*p002)/2. + p003/2. + (5*p010)/4. - (15*p011)/4. + (15*p012)/4. - (5*p013)/4. - p020 + 3*p021 - 3*p022 + p023 + p030/4. - (3*p031)/4. + (3*p032)/4. - p033/4. + (5*p100)/4. - (15*p101)/4. +                 (15*p102)/4. - (5*p103)/4. - (25*p110)/8. + (75*p111)/8. - (75*p112)/8. + (25*p113)/8. + (5*p120)/2. - (15*p121)/2. + (15*p122)/2. - (5*p123)/2. - (5*p130)/8. + (15*p131)/8. - (15*p132)/8. + (5*p133)/8. - p200 + 3*p201 -                  3*p202 + p203 + (5*p210)/2. - (15*p211)/2. + (15*p212)/2. - (5*p213)/2. - 2*p220 + 6*p221 - 6*p222 + 2*p223 + p230/2. - (3*p231)/2. + (3*p232)/2. - p233/2. + p300/4. - (3*p301)/4. + (3*p302)/4. - p303/4. - (5*p310)/8. +                 (15*p311)/8. - (15*p312)/8. + (5*p313)/8. + p320/2. - (3*p321)/2. + (3*p322)/2. - p323/2. - p330/8. + (3*p331)/8. - (3*p332)/8. + p333/8.;
        a230 = -p001/2. + (3*p011)/2. - (3*p021)/2. + p031/2. + (5*p101)/4. - (15*p111)/4. + (15*p121)/4. - (5*p131)/4. - p201 + 3*p211 - 3*p221 + p231 + p301/4. - (3*p311)/4. + (3*p321)/4. - p331/4.;
        a231 = p000/4. - p002/4. - (3*p010)/4. + (3*p012)/4. + (3*p020)/4. - (3*p022)/4. - p030/4. + p032/4. - (5*p100)/8. + (5*p102)/8. + (15*p110)/8. - (15*p112)/8. - (15*p120)/8. + (15*p122)/8. + (5*p130)/8. - (5*p132)/8. + p200/2. - p202/2. - (3*p210)/2. + (3*p212)/2. + (3*p220)/2. - (3*p222)/2. - p230/2. + p232/2. - p300/8. + p302/8. + (3*p310)/8. - (3*p312)/8. - (3*p320)/8. + (3*p322)/8. + p330/8. - p332/8.;
        a232 = -p000/2. + (5*p001)/4. - p002 + p003/4. + (3*p010)/2. - (15*p011)/4. + 3*p012 - (3*p013)/4. - (3*p020)/2. + (15*p021)/4. - 3*p022 + (3*p023)/4. + p030/2. - (5*p031)/4. + p032 - p033/4. + (5*p100)/4. - (25*p101)/8. +                 (5*p102)/2. - (5*p103)/8. - (15*p110)/4. + (75*p111)/8. - (15*p112)/2. + (15*p113)/8. + (15*p120)/4. - (75*p121)/8. + (15*p122)/2. - (15*p123)/8. - (5*p130)/4. + (25*p131)/8. - (5*p132)/2. + (5*p133)/8. - p200 +                 (5*p201)/2. - 2*p202 + p203/2. + 3*p210 - (15*p211)/2. + 6*p212 - (3*p213)/2. - 3*p220 + (15*p221)/2. - 6*p222 + (3*p223)/2. + p230 - (5*p231)/2. + 2*p232 - p233/2. + p300/4. - (5*p301)/8. + p302/2. - p303/8. -                 (3*p310)/4. + (15*p311)/8. - (3*p312)/2. + (3*p313)/8. + (3*p320)/4. - (15*p321)/8. + (3*p322)/2. - (3*p323)/8. - p330/4. + (5*p331)/8. - p332/2. + p333/8.;
        a233 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - (3*p010)/4. + (9*p011)/4. - (9*p012)/4. + (3*p013)/4. + (3*p020)/4. - (9*p021)/4. + (9*p022)/4. - (3*p023)/4. - p030/4. + (3*p031)/4. - (3*p032)/4. + p033/4. - (5*p100)/8. +                 (15*p101)/8. - (15*p102)/8. + (5*p103)/8. + (15*p110)/8. - (45*p111)/8. + (45*p112)/8. - (15*p113)/8. - (15*p120)/8. + (45*p121)/8. - (45*p122)/8. + (15*p123)/8. + (5*p130)/8. - (15*p131)/8. + (15*p132)/8. -                 (5*p133)/8. + p200/2. - (3*p201)/2. + (3*p202)/2. - p203/2. - (3*p210)/2. + (9*p211)/2. - (9*p212)/2. + (3*p213)/2. + (3*p220)/2. - (9*p221)/2. + (9*p222)/2. - (3*p223)/2. - p230/2. + (3*p231)/2. - (3*p232)/2. +                 p233/2. - p300/8. + (3*p301)/8. - (3*p302)/8. + p303/8. + (3*p310)/8. - (9*p311)/8. + (9*p312)/8. - (3*p313)/8. - (3*p320)/8. + (9*p321)/8. - (9*p322)/8. + (3*p323)/8. + p330/8. - (3*p331)/8. + (3*p332)/8. - p333/8.;
        a300 = -p011/2. + (3*p111)/2. - (3*p211)/2. + p311/2.;
        a301 = p010/4. - p012/4. - (3*p110)/4. + (3*p112)/4. + (3*p210)/4. - (3*p212)/4. - p310/4. + p312/4.;
        a302 = -p010/2. + (5*p011)/4. - p012 + p013/4. + (3*p110)/2. - (15*p111)/4. + 3*p112 - (3*p113)/4. - (3*p210)/2. + (15*p211)/4. - 3*p212 + (3*p213)/4. + p310/2. - (5*p311)/4. + p312 - p313/4.;
        a303 = p010/4. - (3*p011)/4. + (3*p012)/4. - p013/4. - (3*p110)/4. + (9*p111)/4. - (9*p112)/4. + (3*p113)/4. + (3*p210)/4. - (9*p211)/4. + (9*p212)/4. - (3*p213)/4. - p310/4. + (3*p311)/4. - (3*p312)/4. + p313/4.;
        a310 = p001/4. - p021/4. - (3*p101)/4. + (3*p121)/4. + (3*p201)/4. - (3*p221)/4. - p301/4. + p321/4.;
        a311 = -p000/8. + p002/8. + p020/8. - p022/8. + (3*p100)/8. - (3*p102)/8. - (3*p120)/8. + (3*p122)/8. - (3*p200)/8. + (3*p202)/8. + (3*p220)/8. - (3*p222)/8. + p300/8. - p302/8. - p320/8. + p322/8.;
        a312 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - p020/4. + (5*p021)/8. - p022/2. + p023/8. - (3*p100)/4. + (15*p101)/8. - (3*p102)/2. + (3*p103)/8. + (3*p120)/4. - (15*p121)/8. + (3*p122)/2. - (3*p123)/8. + (3*p200)/4. -  (15*p201)/8. + (3*p202)/2. - (3*p203)/8. - (3*p220)/4. + (15*p221)/8. - (3*p222)/2. + (3*p223)/8. - p300/4. + (5*p301)/8. - p302/2. + p303/8. + p320/4. - (5*p321)/8. + p322/2. - p323/8.;
        a313 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + p020/8. - (3*p021)/8. + (3*p022)/8. - p023/8. + (3*p100)/8. - (9*p101)/8. + (9*p102)/8. - (3*p103)/8. - (3*p120)/8. + (9*p121)/8. - (9*p122)/8. + (3*p123)/8. - (3*p200)/8. +
                (9*p201)/8. - (9*p202)/8. + (3*p203)/8. + (3*p220)/8. - (9*p221)/8. + (9*p222)/8. - (3*p223)/8. + p300/8. - (3*p301)/8. + (3*p302)/8. - p303/8. - p320/8. + (3*p321)/8. - (3*p322)/8. + p323/8.;
        a320 = -p001/2. + (5*p011)/4. - p021 + p031/4. + (3*p101)/2. - (15*p111)/4. + 3*p121 - (3*p131)/4. - (3*p201)/2. + (15*p211)/4. - 3*p221 + (3*p231)/4. + p301/2. - (5*p311)/4. + p321 - p331/4.;
        a321 = p000/4. - p002/4. - (5*p010)/8. + (5*p012)/8. + p020/2. - p022/2. - p030/8. + p032/8. - (3*p100)/4. + (3*p102)/4. + (15*p110)/8. - (15*p112)/8. - (3*p120)/2. + (3*p122)/2. + (3*p130)/8. - (3*p132)/8. + (3*p200)/4. - (3*p202)/4. - (15*p210)/8. + (15*p212)/8. + (3*p220)/2. - (3*p222)/2. - (3*p230)/8. + (3*p232)/8. - p300/4. + p302/4. + (5*p310)/8. - (5*p312)/8. - p320/2. + p322/2. + p330/8. - p332/8.;
        a322 = -p000/2. + (5*p001)/4. - p002 + p003/4. + (5*p010)/4. - (25*p011)/8. + (5*p012)/2. - (5*p013)/8. - p020 + (5*p021)/2. - 2*p022 + p023/2. + p030/4. - (5*p031)/8. + p032/2. - p033/8. + (3*p100)/2. - (15*p101)/4. + 3*p102 -                 (3*p103)/4. - (15*p110)/4. + (75*p111)/8. - (15*p112)/2. + (15*p113)/8. + 3*p120 - (15*p121)/2. + 6*p122 - (3*p123)/2. - (3*p130)/4. + (15*p131)/8. - (3*p132)/2. + (3*p133)/8. - (3*p200)/2. + (15*p201)/4. - 3*p202 +                 (3*p203)/4. + (15*p210)/4. - (75*p211)/8. + (15*p212)/2. - (15*p213)/8. - 3*p220 + (15*p221)/2. - 6*p222 + (3*p223)/2. + (3*p230)/4. - (15*p231)/8. + (3*p232)/2. - (3*p233)/8. + p300/2. - (5*p301)/4. + p302 - p303/4. -                 (5*p310)/4. + (25*p311)/8. - (5*p312)/2. + (5*p313)/8. + p320 - (5*p321)/2. + 2*p322 - p323/2. - p330/4. + (5*p331)/8. - p332/2. + p333/8.;
        a323 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - (5*p010)/8. + (15*p011)/8. - (15*p012)/8. + (5*p013)/8. + p020/2. - (3*p021)/2. + (3*p022)/2. - p023/2. - p030/8. + (3*p031)/8. - (3*p032)/8. + p033/8. - (3*p100)/4. +                 (9*p101)/4. - (9*p102)/4. + (3*p103)/4. + (15*p110)/8. - (45*p111)/8. + (45*p112)/8. - (15*p113)/8. - (3*p120)/2. + (9*p121)/2. - (9*p122)/2. + (3*p123)/2. + (3*p130)/8. - (9*p131)/8. + (9*p132)/8. - (3*p133)/8. +                 (3*p200)/4. - (9*p201)/4. + (9*p202)/4. - (3*p203)/4. - (15*p210)/8. + (45*p211)/8. - (45*p212)/8. + (15*p213)/8. + (3*p220)/2. - (9*p221)/2. + (9*p222)/2. - (3*p223)/2. - (3*p230)/8. + (9*p231)/8. - (9*p232)/8. +                 (3*p233)/8. - p300/4. + (3*p301)/4. - (3*p302)/4. + p303/4. + (5*p310)/8. - (15*p311)/8. + (15*p312)/8. - (5*p313)/8. - p320/2. + (3*p321)/2. - (3*p322)/2. + p323/2. + p330/8. - (3*p331)/8. + (3*p332)/8. - p333/8.;
        a330 = p001/4. - (3*p011)/4. + (3*p021)/4. - p031/4. - (3*p101)/4. + (9*p111)/4. - (9*p121)/4. + (3*p131)/4. + (3*p201)/4. - (9*p211)/4. + (9*p221)/4. - (3*p231)/4. - p301/4. + (3*p311)/4. - (3*p321)/4. + p331/4.;
        a331 = -p000/8. + p002/8. + (3*p010)/8. - (3*p012)/8. - (3*p020)/8. + (3*p022)/8. + p030/8. - p032/8. + (3*p100)/8. - (3*p102)/8. - (9*p110)/8. + (9*p112)/8. + (9*p120)/8. - (9*p122)/8. - (3*p130)/8. + (3*p132)/8. - (3*p200)/8. +                 (3*p202)/8. + (9*p210)/8. - (9*p212)/8. - (9*p220)/8. + (9*p222)/8. + (3*p230)/8. - (3*p232)/8. + p300/8. - p302/8. - (3*p310)/8. + (3*p312)/8. + (3*p320)/8. - (3*p322)/8. - p330/8. + p332/8.;
        a332 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - (3*p010)/4. + (15*p011)/8. - (3*p012)/2. + (3*p013)/8. + (3*p020)/4. - (15*p021)/8. + (3*p022)/2. - (3*p023)/8. - p030/4. + (5*p031)/8. - p032/2. + p033/8. - (3*p100)/4. +                 (15*p101)/8. - (3*p102)/2. + (3*p103)/8. + (9*p110)/4. - (45*p111)/8. + (9*p112)/2. - (9*p113)/8. - (9*p120)/4. + (45*p121)/8. - (9*p122)/2. + (9*p123)/8. + (3*p130)/4. - (15*p131)/8. + (3*p132)/2. - (3*p133)/8. +                 (3*p200)/4. - (15*p201)/8. + (3*p202)/2. - (3*p203)/8. - (9*p210)/4. + (45*p211)/8. - (9*p212)/2. + (9*p213)/8. + (9*p220)/4. - (45*p221)/8. + (9*p222)/2. - (9*p223)/8. - (3*p230)/4. + (15*p231)/8. - (3*p232)/2. +                 (3*p233)/8. - p300/4. + (5*p301)/8. - p302/2. + p303/8. + (3*p310)/4. - (15*p311)/8. + (3*p312)/2. - (3*p313)/8. - (3*p320)/4. + (15*p321)/8. - (3*p322)/2. + (3*p323)/8. + p330/4. - (5*p331)/8. + p332/2. - p333/8.;
        a333 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + (3*p010)/8. - (9*p011)/8. + (9*p012)/8. - (3*p013)/8. - (3*p020)/8. + (9*p021)/8. - (9*p022)/8. + (3*p023)/8. + p030/8. - (3*p031)/8. + (3*p032)/8. - p033/8. + (3*p100)/8. -                 (9*p101)/8. + (9*p102)/8. - (3*p103)/8. - (9*p110)/8. + (27*p111)/8. - (27*p112)/8. + (9*p113)/8. + (9*p120)/8. - (27*p121)/8. + (27*p122)/8. - (9*p123)/8. - (3*p130)/8. + (9*p131)/8. - (9*p132)/8. + (3*p133)/8. -                 (3*p200)/8. + (9*p201)/8. - (9*p202)/8. + (3*p203)/8. + (9*p210)/8. - (27*p211)/8. + (27*p212)/8. - (9*p213)/8. - (9*p220)/8. + (27*p221)/8. - (27*p222)/8. + (9*p223)/8. + (3*p230)/8. - (9*p231)/8. + (9*p232)/8. -                 (3*p233)/8. + p300/8. - (3*p301)/8. + (3*p302)/8. - p303/8. - (3*p310)/8. + (9*p311)/8. - (9*p312)/8. + (3*p313)/8. + (3*p320)/8. - (9*p321)/8. + (9*p322)/8. - (3*p323)/8. - p330/8. + (3*p331)/8. - (3*p332)/8. + p333/8.;
    }

    double t2 = t*t;      double t3 = t*t2;
    double u2 = u*u;      double u3 = u*u2;
    double v2 = v*v;      double v3 = v*v2;


    // a0 = p1;
    // a1 = -0.5*p0 + 0.5*p2;
    // a2 =      p0 - 2.5*p1 +   2*p2  - 0.5*p3;
    // a3 = -0.5*p0 + 1.5*p1 - 1.5p*2  + 0.5*p3;

    // interp_1d = a0 + a1*t + a2*t2 + a3*t3;
    //
    //       a0  = (a00 + a01*u + a02*u2 + a03*u3;
    //       a1  = (a10 + a11*u + a12*u2 + a13*u3;
    //       a2  = (a20 + a21*u + a22*u2 + a23*u3;
    //       a3  = (a30 + a31*u + a32*u2 + a33*u3;
    //
    // interp_2d = (a00 + a01*u + a02*u2 + a03*u3)        +
    //             (a10 + a11*u + a12*u2 + a13*u3) * t    +
    //             (a20 + a21*u + a22*u2 + a23*u3) * t2   +
    //             (a30 + a31*u + a32*u2 + a33*u3) * t3;
    //
    // a00 = (a000 + a001*v + a002*v2 + a003*v3);
    // a01 = (a010 + a011*v + a012*v2 + a013*v3);
    // a02 = (a020 + a021*v + a022*v2 + a023*v3);
    // a03 = (a030 + a031*v + a032*v2 + a033*v3);
    // a10 = (a100 + a101*v + a102*v2 + a103*v3);
    // a11 = (a110 + a111*v + a112*v2 + a113*v3);
    // a12 = (a120 + a121*v + a122*v2 + a123*v3);
    // a13 = (a130 + a131*v + a132*v2 + a133*v3);
    // a20 = (a200 + a201*v + a202*v2 + a203*v3);
    // a21 = (a210 + a211*v + a212*v2 + a213*v3);
    // a22 = (a220 + a221*v + a222*v2 + a223*v3);
    // a23 = (a230 + a231*v + a232*v2 + a233*v3);
    // a30 = (a300 + a301*v + a302*v2 + a303*v3);
    // a31 = (a310 + a311*v + a312*v2 + a313*v3);
    // a32 = (a320 + a321*v + a322*v2 + a323*v3);
    // a33 = (a330 + a331*v + a332*v2 + a333*v3);
    //
    //
    // a00 = p[1][1];
    // a01 = -.5*p[1][0] + .5*p[1][2];
    // a02 = p[1][0] - 2.5*p[1][1] + 2*p[1][2] - .5*p[1][3];
    // a03 = -.5*p[1][0] + 1.5*p[1][1] - 1.5*p[1][2] + .5*p[1][3];
    // a10 = -.5*p[0][1] + .5*p[2][1];
    // a11 = .25*p[0][0] - .25*p[0][2] - .25*p[2][0] + .25*p[2][2];
    // a12 = -.5*p[0][0] + 1.25*p[0][1] - p[0][2] + .25*p[0][3] + .5*p[2][0] - 1.25*p[2][1] + p[2][2] - .25*p[2][3];
    // a13 = .25*p[0][0] - .75*p[0][1] + .75*p[0][2] - .25*p[0][3] - .25*p[2][0] + .75*p[2][1] - .75*p[2][2] + .25*p[2][3];
    // a20 = p[0][1] - 2.5*p[1][1] + 2*p[2][1] - .5*p[3][1];
    // a21 = -.5*p[0][0] + .5*p[0][2] + 1.25*p[1][0] - 1.25*p[1][2] - p[2][0] + p[2][2] + .25*p[3][0] - .25*p[3][2];
    // a22 = p[0][0] - 2.5*p[0][1] + 2*p[0][2] - .5*p[0][3] - 2.5*p[1][0] + 6.25*p[1][1] - 5*p[1][2] + 1.25*p[1][3] + 2*p[2][0] - 5*p[2][1] + 4*p[2][2] - p[2][3] - .5*p[3][0] + 1.25*p[3][1] - p[3][2] + .25*p[3][3];
    // a23 = -.5*p[0][0] + 1.5*p[0][1] - 1.5*p[0][2] + .5*p[0][3] + 1.25*p[1][0] - 3.75*p[1][1] + 3.75*p[1][2] - 1.25*p[1][3] - p[2][0] + 3*p[2][1] - 3*p[2][2] + p[2][3] + .25*p[3][0] - .75*p[3][1] + .75*p[3][2] - .25*p[3][3];
    // a30 = -.5*p[0][1] + 1.5*p[1][1] - 1.5*p[2][1] + .5*p[3][1];
    // a31 = .25*p[0][0] - .25*p[0][2] - .75*p[1][0] + .75*p[1][2] + .75*p[2][0] - .75*p[2][2] - .25*p[3][0] + .25*p[3][2];
    // a32 = -.5*p[0][0] + 1.25*p[0][1] - p[0][2] + .25*p[0][3] + 1.5*p[1][0] - 3.75*p[1][1] + 3*p[1][2] - .75*p[1][3] - 1.5*p[2][0] + 3.75*p[2][1] - 3*p[2][2] + .75*p[2][3] + .5*p[3][0] - 1.25*p[3][1] + p[3][2] - .25*p[3][3];
    // a33 = .25*p[0][0] - .75*p[0][1] + .75*p[0][2] - .25*p[0][3] - .75*p[1][0] + 2.25*p[1][1] - 2.25*p[1][2] + .75*p[1][3] + .75*p[2][0] - 2.25*p[2][1] + 2.25*p[2][2] - .75*p[2][3] - .25*p[3][0] + .75*p[3][1] - .75*p[3][2] + .25*p[3][3];

    // a00 = a0             where   p1 joins p1 to become p11
    // a11 = a01 * a10;     where   p_ij * p_kl = p_(i*k)(j*l)
    // a21 = a01 * a20;
    // a22 = a02 * a20;
    // a33 = a03 * a30;
    // aij = ai0 * a0j;

    // interp_3d =   ((a000 + a001*v + a002*v2 + a003*v3) + (a010 + a011*v + a012*v2 + a013*v3)*u + (a020 + a021*v + a022*v2 + a023*v3)*u2 + (a030 + a031*v + a032*v2 + a033*v3)*u3)        +
    //               ((a100 + a101*v + a102*v2 + a103*v3) + (a110 + a111*v + a112*v2 + a113*v3)*u + (a120 + a121*v + a122*v2 + a123*v3)*u2 + (a130 + a131*v + a132*v2 + a133*v3)*u3) * t    +
    //               ((a200 + a201*v + a202*v2 + a203*v3) + (a210 + a211*v + a212*v2 + a213*v3)*u + (a220 + a221*v + a222*v2 + a223*v3)*u2 + (a230 + a231*v + a232*v2 + a233*v3)*u3) * t2   +
    //               ((a300 + a301*v + a302*v2 + a303*v3) + (a310 + a311*v + a312*v2 + a313*v3)*u + (a320 + a321*v + a322*v2 + a323*v3)*u2 + (a330 + a331*v + a332*v2 + a333*v3)*u3) * t3;

    double value = ((a000 + a001*v + a002*v2 + a003*v3) + (a010 + a011*v + a012*v2 + a013*v3)*u + (a020 + a021*v + a022*v2 + a023*v3)*u2 + (a030 + a031*v + a032*v2 + a033*v3)*u3)        +
                   ((a100 + a101*v + a102*v2 + a103*v3) + (a110 + a111*v + a112*v2 + a113*v3)*u + (a120 + a121*v + a122*v2 + a123*v3)*u2 + (a130 + a131*v + a132*v2 + a133*v3)*u3) * t    +
                   ((a200 + a201*v + a202*v2 + a203*v3) + (a210 + a211*v + a212*v2 + a213*v3)*u + (a220 + a221*v + a222*v2 + a223*v3)*u2 + (a230 + a231*v + a232*v2 + a233*v3)*u3) * t2   +
                   ((a300 + a301*v + a302*v2 + a303*v3) + (a310 + a311*v + a312*v2 + a313*v3)*u + (a320 + a321*v + a322*v2 + a323*v3)*u2 + (a330 + a331*v + a332*v2 + a333*v3)*u3) * t3;


    return value;
}

template <typename T>
vec3 ScalarField<T>::cachedTricubicGradientAt(const vec3 &x) const
{
    return cachedTricubicGradientAt(x.x, x.y, x.z);
}

template <typename T>
vec3 ScalarField<T>::cachedTricubicGradientAt(double x, double y, double z) const
{
    static double a000, a001, a002, a003,    a010, a011, a012, a013,    a020, a021, a022, a023,    a030, a031, a032, a033;
    static double a100, a101, a102, a103,    a110, a111, a112, a113,    a120, a121, a122, a123,    a130, a131, a132, a133;
    static double a200, a201, a202, a203,    a210, a211, a212, a213,    a220, a221, a222, a223,    a230, a231, a232, a233;
    static double a300, a301, a302, a303,    a310, a311, a312, a313,    a320, a321, a322, a323,    a330, a331, a332, a333;

    static double p000, p001, p002, p003,    p010, p011, p012, p013,    p020, p021, p022, p023,    p030, p031, p032, p033;
    static double p100, p101, p102, p103,    p110, p111, p112, p113,    p120, p121, p122, p123,    p130, p131, p132, p133;
    static double p200, p201, p202, p203,    p210, p211, p212, p213,    p220, p221, p222, p223,    p230, p231, p232, p233;
    static double p300, p301, p302, p303,    p310, p311, p312, p313,    p320, p321, p322, p323,    p330, p331, p332, p333;

    static double a[4][4][4] = {0};
    double p[4][4][4] = {0};

    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered)
    {
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    // Get Interpolation Offset
    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    // Get Coordinate Offset
    int x0 = (int)floor(x);
    int y0 = (int)floor(y);
    int z0 = (int)floor(z);

    // Determine Clamping
    vec3 clamp_range;
    if(m_centeringType == CellCentered)
        clamp_range = vec3(m_w-1, m_h-1, m_d-1);
    else if(m_centeringType == NodeCentered)
        clamp_range = vec3(m_w-2, m_h-2, m_d-2);

    // recalculate coefficients if in new cell than last call
    /*
    static int prev_int_x = 0;
    static int prev_int_y = 0;
    static int prev_int_z = 0;

    if(prev_int_x != int_x ||
       prev_int_y != int_y ||
       prev_int_z != int_z)
    {
        prev_int_x = int_x;
        prev_int_y = int_y;
        prev_int_z = int_z;

        // ....
    }*/

    // Grab All 64 Values
    for(int k=0; k < 4; k++){
        for(int j=0; j < 4; j++){
            for(int i=0; i < 4; i++){

                // adjust to match grid
                int ii = x0 + i - 1;
                int jj = y0 + j - 1;
                int kk = z0 + k - 1;

                // then clamp to be in bounds
                ii = clamp(ii, 0, (int)clamp_range.x);
                jj = clamp(jj, 0, (int)clamp_range.y);
                kk = clamp(kk, 0, (int)clamp_range.z);

                // then query value
                p[i][j][k] = m_data[ii + jj*m_w + kk*m_w*m_h];
            }
        }
    }

    p000 = p[0][0][0];
    p001 = p[0][0][1];
    p002 = p[0][0][2];
    p003 = p[0][0][3];
    p010 = p[0][1][0];
    p011 = p[0][1][1];
    p012 = p[0][1][2];
    p013 = p[0][1][3];
    p020 = p[0][2][0];
    p021 = p[0][2][1];
    p022 = p[0][2][2];
    p023 = p[0][2][3];
    p030 = p[0][3][0];
    p031 = p[0][3][1];
    p032 = p[0][3][2];
    p033 = p[0][3][3];
    p100 = p[1][0][0];
    p101 = p[1][0][1];
    p102 = p[1][0][2];
    p103 = p[1][0][3];
    p110 = p[1][1][0];
    p111 = p[1][1][1];
    p112 = p[1][1][2];
    p113 = p[1][1][3];
    p120 = p[1][2][0];
    p121 = p[1][2][1];
    p122 = p[1][2][2];
    p123 = p[1][2][3];
    p130 = p[1][3][0];
    p131 = p[1][3][1];
    p132 = p[1][3][2];
    p133 = p[1][3][3];
    p200 = p[2][0][0];
    p201 = p[2][0][1];
    p202 = p[2][0][2];
    p203 = p[2][0][3];
    p210 = p[2][1][0];
    p211 = p[2][1][1];
    p212 = p[2][1][2];
    p213 = p[2][1][3];
    p220 = p[2][2][0];
    p221 = p[2][2][1];
    p222 = p[2][2][2];
    p223 = p[2][2][3];
    p230 = p[2][3][0];
    p231 = p[2][3][1];
    p232 = p[2][3][2];
    p233 = p[2][3][3];
    p300 = p[3][0][0];
    p301 = p[3][0][1];
    p302 = p[3][0][2];
    p303 = p[3][0][3];
    p310 = p[3][1][0];
    p311 = p[3][1][1];
    p312 = p[3][1][2];
    p313 = p[3][1][3];
    p320 = p[3][2][0];
    p321 = p[3][2][1];
    p322 = p[3][2][2];
    p323 = p[3][2][3];
    p330 = p[3][3][0];
    p331 = p[3][3][1];
    p332 = p[3][3][2];
    p333 = p[3][3][3];

    // CForm[Coefficient[Collect[Coefficient[b, y, 0], z], z, 0]]
    // update coefficients (todo: make separate function)
    {
        a000 = p111;                                            //  a = Coefficient[p, x, 0]        Collect[Coefficient[a, y, 0], z]
        a001 = -p110/2. + p112/2.;
        a002 = p110 - (5*p111)/2. + 2*p112 - p113/2.;
        a003 = -p110/2. + (3*p111)/2. - (3*p112)/2. + p113/2.;
        a010 = -p101/2. + p121/2.;
        a011 = (p100/2. - p102/2.)/2. + (-p120/2. + p122/2.)/2.;
        a012 = (-p100 + (5*p101)/2. - 2*p102 + p103/2.)/2. + (p120 - (5*p121)/2. + 2*p122 - p123/2.)/2.;
        a013 = (p100/2. - (3*p101)/2. + (3*p102)/2. - p103/2.)/2. + (-p120/2. + (3*p121)/2. - (3*p122)/2. + p123/2.)/2.;
        a020 = p101 - (5*p111)/2. + 2*p121 - p131/2.;
        a021 = -p100/2. + p102/2. - (5*(-p110/2. + p112/2.))/2. + 2*(-p120/2. + p122/2.) + (p130/2. - p132/2.)/2.;
        a022 = p100 - (5*p101)/2. + 2*p102 - p103/2. - (5*(p110 - (5*p111)/2. + 2*p112 - p113/2.))/2. + 2*(p120 - (5*p121)/2. + 2*p122 - p123/2.) + (-p130 + (5*p131)/2. - 2*p132 + p133/2.)/2.;
        a023 = -p100/2. + (3*p101)/2. - (3*p102)/2. + p103/2. - (5*(-p110/2. + (3*p111)/2. - (3*p112)/2. + p113/2.))/2. + 2*(-p120/2. + (3*p121)/2. - (3*p122)/2. + p123/2.) + (p130/2. - (3*p131)/2. + (3*p132)/2. - p133/2.)/2.;
        a030 = -p101/2. + (3*p111)/2. - (3*p121)/2. + p131/2.;
        a031 = (p100/2. - p102/2.)/2. + (3*(-p110/2. + p112/2.))/2. - (3*(-p120/2. + p122/2.))/2. + (-p130/2. + p132/2.)/2.;
        a032 = (-p100 + (5*p101)/2. - 2*p102 + p103/2.)/2. + (3*(p110 - (5*p111)/2. + 2*p112 - p113/2.))/2. - (3*(p120 - (5*p121)/2. + 2*p122 - p123/2.))/2. + (p130 - (5*p131)/2. + 2*p132 - p133/2.)/2.;
        a033 = (p100/2. - (3*p101)/2. + (3*p102)/2. - p103/2.)/2. + (3*(-p110/2. + (3*p111)/2. - (3*p112)/2. + p113/2.))/2. - (3*(-p120/2. + (3*p121)/2. - (3*p122)/2. + p123/2.))/2. + (-p130/2. + (3*p131)/2. - (3*p132)/2. + p133/2.)/2.;
        a100 = -p011/2. + p211/2.;
        a101 = p010/4. - p012/4. - p210/4. + p212/4.;
        a102 = -p010/2. + (5*p011)/4. - p012 + p013/4. + p210/2. - (5*p211)/4. + p212 - p213/4.;
        a103 = p010/4. - (3*p011)/4. + (3*p012)/4. - p013/4. - p210/4. + (3*p211)/4. - (3*p212)/4. + p213/4.;
        a110 = p001/4. - p021/4. - p201/4. + p221/4.;
        a111 = -p000/8. + p002/8. + p020/8. - p022/8. + p200/8. - p202/8. - p220/8. + p222/8.;
        a112 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - p020/4. + (5*p021)/8. - p022/2. + p023/8. - p200/4. + (5*p201)/8. - p202/2. + p203/8. + p220/4. - (5*p221)/8. + p222/2. - p223/8.;
        a113 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + p020/8. - (3*p021)/8. + (3*p022)/8. - p023/8. + p200/8. - (3*p201)/8. + (3*p202)/8. - p203/8. - p220/8. + (3*p221)/8. - (3*p222)/8. + p223/8.;
        a120 = -p001/2. + (5*p011)/4. - p021 + p031/4. + p201/2. - (5*p211)/4. + p221 - p231/4.;
        a121 = p000/4. - p002/4. - (5*p010)/8. + (5*p012)/8. + p020/2. - p022/2. - p030/8. + p032/8. - p200/4. + p202/4. + (5*p210)/8. - (5*p212)/8. - p220/2. + p222/2. + p230/8. - p232/8.;
        a122 = -p000/2. + (5*p001)/4. - p002 + p003/4. + (5*p010)/4. - (25*p011)/8. + (5*p012)/2. - (5*p013)/8. - p020 + (5*p021)/2. - 2*p022 + p023/2. + p030/4. - (5*p031)/8. + p032/2. - p033/8. + p200/2. - (5*p201)/4. + p202 - p203/4. - (5*p210)/4. + (25*p211)/8. - (5*p212)/2. + (5*p213)/8. + p220 - (5*p221)/2. + 2*p222 - p223/2. - p230/4. + (5*p231)/8. - p232/2. + p233/8.;
        a123 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - (5*p010)/8. + (15*p011)/8. - (15*p012)/8. + (5*p013)/8. + p020/2. - (3*p021)/2. + (3*p022)/2. - p023/2. - p030/8. + (3*p031)/8. - (3*p032)/8. + p033/8. - p200/4. + (3*p201)/4. - (3*p202)/4. + p203/4. + (5*p210)/8. - (15*p211)/8. + (15*p212)/8. - (5*p213)/8. - p220/2. + (3*p221)/2. - (3*p222)/2. + p223/2. + p230/8. - (3*p231)/8. + (3*p232)/8. - p233/8.;
        a130 = p001/4. - (3*p011)/4. + (3*p021)/4. - p031/4. - p201/4. + (3*p211)/4. - (3*p221)/4. + p231/4.;
        a131 = -p000/8. + p002/8. + (3*p010)/8. - (3*p012)/8. - (3*p020)/8. + (3*p022)/8. + p030/8. - p032/8. + p200/8. - p202/8. - (3*p210)/8. + (3*p212)/8. + (3*p220)/8. - (3*p222)/8. - p230/8. + p232/8.;
        a132 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - (3*p010)/4. + (15*p011)/8. - (3*p012)/2. + (3*p013)/8. + (3*p020)/4. - (15*p021)/8. + (3*p022)/2. - (3*p023)/8. - p030/4. + (5*p031)/8. - p032/2. + p033/8. - p200/4. + (5*p201)/8. - p202/2. + p203/8. + (3*p210)/4. - (15*p211)/8. + (3*p212)/2. - (3*p213)/8. - (3*p220)/4. + (15*p221)/8. - (3*p222)/2. + (3*p223)/8. + p230/4. - (5*p231)/8. + p232/2. - p233/8.;
        a133 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + (3*p010)/8. - (9*p011)/8. + (9*p012)/8. - (3*p013)/8. - (3*p020)/8. + (9*p021)/8. - (9*p022)/8. + (3*p023)/8. + p030/8. - (3*p031)/8. + (3*p032)/8. - p033/8. + p200/8. - (3*p201)/8. + (3*p202)/8. - p203/8. - (3*p210)/8. + (9*p211)/8. - (9*p212)/8. + (3*p213)/8. + (3*p220)/8. - (9*p221)/8. + (9*p222)/8. - (3*p223)/8. - p230/8. + (3*p231)/8. - (3*p232)/8. + p233/8.;
        a200 = p011 - (5*p111)/2. + 2*p211 - p311/2.;
        a201 = -p010/2. + p012/2. + (5*p110)/4. - (5*p112)/4. - p210 + p212 + p310/4. - p312/4.;
        a202 = p010 - (5*p011)/2. + 2*p012 - p013/2. - (5*p110)/2. + (25*p111)/4. - 5*p112 + (5*p113)/4. + 2*p210 - 5*p211 + 4*p212 - p213 - p310/2. + (5*p311)/4. - p312 + p313/4.;
        a203 = -p010/2. + (3*p011)/2. - (3*p012)/2. + p013/2. + (5*p110)/4. - (15*p111)/4. + (15*p112)/4. - (5*p113)/4. - p210 + 3*p211 - 3*p212 + p213 + p310/4. - (3*p311)/4. + (3*p312)/4. - p313/4.;
        a210 = -p001/2. + p021/2. + (5*p101)/4. - (5*p121)/4. - p201 + p221 + p301/4. - p321/4.;
        a211 = p000/4. - p002/4. - p020/4. + p022/4. - (5*p100)/8. + (5*p102)/8. + (5*p120)/8. - (5*p122)/8. + p200/2. - p202/2. - p220/2. + p222/2. - p300/8. + p302/8. + p320/8. - p322/8.;
        a212 = -p000/2. + (5*p001)/4. - p002 + p003/4. + p020/2. - (5*p021)/4. + p022 - p023/4. + (5*p100)/4. - (25*p101)/8. + (5*p102)/2. - (5*p103)/8. - (5*p120)/4. + (25*p121)/8. - (5*p122)/2. + (5*p123)/8. - p200 + (5*p201)/2. - 2*p202 + p203/2. + p220 - (5*p221)/2. + 2*p222 - p223/2. + p300/4. - (5*p301)/8. + p302/2. - p303/8. - p320/4. + (5*p321)/8. - p322/2. + p323/8.;
        a213 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - p020/4. + (3*p021)/4. - (3*p022)/4. + p023/4. - (5*p100)/8. + (15*p101)/8. - (15*p102)/8. + (5*p103)/8. + (5*p120)/8. - (15*p121)/8. + (15*p122)/8. - (5*p123)/8. + p200/2. - (3*p201)/2. + (3*p202)/2. - p203/2. - p220/2. + (3*p221)/2. - (3*p222)/2. + p223/2. - p300/8. + (3*p301)/8. - (3*p302)/8. + p303/8. + p320/8. - (3*p321)/8. + (3*p322)/8. - p323/8.;
        a220 = p001 - (5*p011)/2. + 2*p021 - p031/2. - (5*p101)/2. + (25*p111)/4. - 5*p121 + (5*p131)/4. + 2*p201 - 5*p211 + 4*p221 - p231 - p301/2. + (5*p311)/4. - p321 + p331/4.;
        a221 = -p000/2. + p002/2. + (5*p010)/4. - (5*p012)/4. - p020 + p022 + p030/4. - p032/4. + (5*p100)/4. - (5*p102)/4. - (25*p110)/8. + (25*p112)/8. + (5*p120)/2. - (5*p122)/2. - (5*p130)/8. + (5*p132)/8. - p200 + p202 + (5*p210)/2. - (5*p212)/2. - 2*p220 + 2*p222 + p230/2. - p232/2. + p300/4. - p302/4. - (5*p310)/8. + (5*p312)/8. + p320/2. - p322/2. - p330/8. + p332/8.;
        a222 = p000 - (5*p001)/2. + 2*p002 - p003/2. - (5*p010)/2. + (25*p011)/4. - 5*p012 + (5*p013)/4. + 2*p020 - 5*p021 + 4*p022 - p023 - p030/2. + (5*p031)/4. - p032 + p033/4. - (5*p100)/2. + (25*p101)/4. - 5*p102 + (5*p103)/4. + (25*p110)/4. - (125*p111)/8. + (25*p112)/2. - (25*p113)/8. - 5*p120 + (25*p121)/2. - 10*p122 + (5*p123)/2. + (5*p130)/4. - (25*p131)/8. + (5*p132)/2. - (5*p133)/8. + 2*p200 - 5*p201 + 4*p202 - p203 - 5*p210 + (25*p211)/2. - 10*p212 + (5*p213)/2. + 4*p220 - 10*p221 + 8*p222 - 2*p223 - p230 + (5*p231)/2. - 2*p232 + p233/2. - p300/2. + (5*p301)/4. - p302 + p303/4. + (5*p310)/4. - (25*p311)/8. + (5*p312)/2. - (5*p313)/8. - p320 + (5*p321)/2. - 2*p322 + p323/2. + p330/4. - (5*p331)/8. + p332/2. - p333/8.;
        a223 = -p000/2. + (3*p001)/2. - (3*p002)/2. + p003/2. + (5*p010)/4. - (15*p011)/4. + (15*p012)/4. - (5*p013)/4. - p020 + 3*p021 - 3*p022 + p023 + p030/4. - (3*p031)/4. + (3*p032)/4. - p033/4. + (5*p100)/4. - (15*p101)/4. +                 (15*p102)/4. - (5*p103)/4. - (25*p110)/8. + (75*p111)/8. - (75*p112)/8. + (25*p113)/8. + (5*p120)/2. - (15*p121)/2. + (15*p122)/2. - (5*p123)/2. - (5*p130)/8. + (15*p131)/8. - (15*p132)/8. + (5*p133)/8. - p200 + 3*p201 -                  3*p202 + p203 + (5*p210)/2. - (15*p211)/2. + (15*p212)/2. - (5*p213)/2. - 2*p220 + 6*p221 - 6*p222 + 2*p223 + p230/2. - (3*p231)/2. + (3*p232)/2. - p233/2. + p300/4. - (3*p301)/4. + (3*p302)/4. - p303/4. - (5*p310)/8. +                 (15*p311)/8. - (15*p312)/8. + (5*p313)/8. + p320/2. - (3*p321)/2. + (3*p322)/2. - p323/2. - p330/8. + (3*p331)/8. - (3*p332)/8. + p333/8.;
        a230 = -p001/2. + (3*p011)/2. - (3*p021)/2. + p031/2. + (5*p101)/4. - (15*p111)/4. + (15*p121)/4. - (5*p131)/4. - p201 + 3*p211 - 3*p221 + p231 + p301/4. - (3*p311)/4. + (3*p321)/4. - p331/4.;
        a231 = p000/4. - p002/4. - (3*p010)/4. + (3*p012)/4. + (3*p020)/4. - (3*p022)/4. - p030/4. + p032/4. - (5*p100)/8. + (5*p102)/8. + (15*p110)/8. - (15*p112)/8. - (15*p120)/8. + (15*p122)/8. + (5*p130)/8. - (5*p132)/8. + p200/2. - p202/2. - (3*p210)/2. + (3*p212)/2. + (3*p220)/2. - (3*p222)/2. - p230/2. + p232/2. - p300/8. + p302/8. + (3*p310)/8. - (3*p312)/8. - (3*p320)/8. + (3*p322)/8. + p330/8. - p332/8.;
        a232 = -p000/2. + (5*p001)/4. - p002 + p003/4. + (3*p010)/2. - (15*p011)/4. + 3*p012 - (3*p013)/4. - (3*p020)/2. + (15*p021)/4. - 3*p022 + (3*p023)/4. + p030/2. - (5*p031)/4. + p032 - p033/4. + (5*p100)/4. - (25*p101)/8. +                 (5*p102)/2. - (5*p103)/8. - (15*p110)/4. + (75*p111)/8. - (15*p112)/2. + (15*p113)/8. + (15*p120)/4. - (75*p121)/8. + (15*p122)/2. - (15*p123)/8. - (5*p130)/4. + (25*p131)/8. - (5*p132)/2. + (5*p133)/8. - p200 +                 (5*p201)/2. - 2*p202 + p203/2. + 3*p210 - (15*p211)/2. + 6*p212 - (3*p213)/2. - 3*p220 + (15*p221)/2. - 6*p222 + (3*p223)/2. + p230 - (5*p231)/2. + 2*p232 - p233/2. + p300/4. - (5*p301)/8. + p302/2. - p303/8. -                 (3*p310)/4. + (15*p311)/8. - (3*p312)/2. + (3*p313)/8. + (3*p320)/4. - (15*p321)/8. + (3*p322)/2. - (3*p323)/8. - p330/4. + (5*p331)/8. - p332/2. + p333/8.;
        a233 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - (3*p010)/4. + (9*p011)/4. - (9*p012)/4. + (3*p013)/4. + (3*p020)/4. - (9*p021)/4. + (9*p022)/4. - (3*p023)/4. - p030/4. + (3*p031)/4. - (3*p032)/4. + p033/4. - (5*p100)/8. +                 (15*p101)/8. - (15*p102)/8. + (5*p103)/8. + (15*p110)/8. - (45*p111)/8. + (45*p112)/8. - (15*p113)/8. - (15*p120)/8. + (45*p121)/8. - (45*p122)/8. + (15*p123)/8. + (5*p130)/8. - (15*p131)/8. + (15*p132)/8. -                 (5*p133)/8. + p200/2. - (3*p201)/2. + (3*p202)/2. - p203/2. - (3*p210)/2. + (9*p211)/2. - (9*p212)/2. + (3*p213)/2. + (3*p220)/2. - (9*p221)/2. + (9*p222)/2. - (3*p223)/2. - p230/2. + (3*p231)/2. - (3*p232)/2. +                 p233/2. - p300/8. + (3*p301)/8. - (3*p302)/8. + p303/8. + (3*p310)/8. - (9*p311)/8. + (9*p312)/8. - (3*p313)/8. - (3*p320)/8. + (9*p321)/8. - (9*p322)/8. + (3*p323)/8. + p330/8. - (3*p331)/8. + (3*p332)/8. - p333/8.;
        a300 = -p011/2. + (3*p111)/2. - (3*p211)/2. + p311/2.;
        a301 = p010/4. - p012/4. - (3*p110)/4. + (3*p112)/4. + (3*p210)/4. - (3*p212)/4. - p310/4. + p312/4.;
        a302 = -p010/2. + (5*p011)/4. - p012 + p013/4. + (3*p110)/2. - (15*p111)/4. + 3*p112 - (3*p113)/4. - (3*p210)/2. + (15*p211)/4. - 3*p212 + (3*p213)/4. + p310/2. - (5*p311)/4. + p312 - p313/4.;
        a303 = p010/4. - (3*p011)/4. + (3*p012)/4. - p013/4. - (3*p110)/4. + (9*p111)/4. - (9*p112)/4. + (3*p113)/4. + (3*p210)/4. - (9*p211)/4. + (9*p212)/4. - (3*p213)/4. - p310/4. + (3*p311)/4. - (3*p312)/4. + p313/4.;
        a310 = p001/4. - p021/4. - (3*p101)/4. + (3*p121)/4. + (3*p201)/4. - (3*p221)/4. - p301/4. + p321/4.;
        a311 = -p000/8. + p002/8. + p020/8. - p022/8. + (3*p100)/8. - (3*p102)/8. - (3*p120)/8. + (3*p122)/8. - (3*p200)/8. + (3*p202)/8. + (3*p220)/8. - (3*p222)/8. + p300/8. - p302/8. - p320/8. + p322/8.;
        a312 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - p020/4. + (5*p021)/8. - p022/2. + p023/8. - (3*p100)/4. + (15*p101)/8. - (3*p102)/2. + (3*p103)/8. + (3*p120)/4. - (15*p121)/8. + (3*p122)/2. - (3*p123)/8. + (3*p200)/4. -  (15*p201)/8. + (3*p202)/2. - (3*p203)/8. - (3*p220)/4. + (15*p221)/8. - (3*p222)/2. + (3*p223)/8. - p300/4. + (5*p301)/8. - p302/2. + p303/8. + p320/4. - (5*p321)/8. + p322/2. - p323/8.;
        a313 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + p020/8. - (3*p021)/8. + (3*p022)/8. - p023/8. + (3*p100)/8. - (9*p101)/8. + (9*p102)/8. - (3*p103)/8. - (3*p120)/8. + (9*p121)/8. - (9*p122)/8. + (3*p123)/8. - (3*p200)/8. +
                (9*p201)/8. - (9*p202)/8. + (3*p203)/8. + (3*p220)/8. - (9*p221)/8. + (9*p222)/8. - (3*p223)/8. + p300/8. - (3*p301)/8. + (3*p302)/8. - p303/8. - p320/8. + (3*p321)/8. - (3*p322)/8. + p323/8.;
        a320 = -p001/2. + (5*p011)/4. - p021 + p031/4. + (3*p101)/2. - (15*p111)/4. + 3*p121 - (3*p131)/4. - (3*p201)/2. + (15*p211)/4. - 3*p221 + (3*p231)/4. + p301/2. - (5*p311)/4. + p321 - p331/4.;
        a321 = p000/4. - p002/4. - (5*p010)/8. + (5*p012)/8. + p020/2. - p022/2. - p030/8. + p032/8. - (3*p100)/4. + (3*p102)/4. + (15*p110)/8. - (15*p112)/8. - (3*p120)/2. + (3*p122)/2. + (3*p130)/8. - (3*p132)/8. + (3*p200)/4. - (3*p202)/4. - (15*p210)/8. + (15*p212)/8. + (3*p220)/2. - (3*p222)/2. - (3*p230)/8. + (3*p232)/8. - p300/4. + p302/4. + (5*p310)/8. - (5*p312)/8. - p320/2. + p322/2. + p330/8. - p332/8.;
        a322 = -p000/2. + (5*p001)/4. - p002 + p003/4. + (5*p010)/4. - (25*p011)/8. + (5*p012)/2. - (5*p013)/8. - p020 + (5*p021)/2. - 2*p022 + p023/2. + p030/4. - (5*p031)/8. + p032/2. - p033/8. + (3*p100)/2. - (15*p101)/4. + 3*p102 -                 (3*p103)/4. - (15*p110)/4. + (75*p111)/8. - (15*p112)/2. + (15*p113)/8. + 3*p120 - (15*p121)/2. + 6*p122 - (3*p123)/2. - (3*p130)/4. + (15*p131)/8. - (3*p132)/2. + (3*p133)/8. - (3*p200)/2. + (15*p201)/4. - 3*p202 +                 (3*p203)/4. + (15*p210)/4. - (75*p211)/8. + (15*p212)/2. - (15*p213)/8. - 3*p220 + (15*p221)/2. - 6*p222 + (3*p223)/2. + (3*p230)/4. - (15*p231)/8. + (3*p232)/2. - (3*p233)/8. + p300/2. - (5*p301)/4. + p302 - p303/4. -                 (5*p310)/4. + (25*p311)/8. - (5*p312)/2. + (5*p313)/8. + p320 - (5*p321)/2. + 2*p322 - p323/2. - p330/4. + (5*p331)/8. - p332/2. + p333/8.;
        a323 = p000/4. - (3*p001)/4. + (3*p002)/4. - p003/4. - (5*p010)/8. + (15*p011)/8. - (15*p012)/8. + (5*p013)/8. + p020/2. - (3*p021)/2. + (3*p022)/2. - p023/2. - p030/8. + (3*p031)/8. - (3*p032)/8. + p033/8. - (3*p100)/4. +                 (9*p101)/4. - (9*p102)/4. + (3*p103)/4. + (15*p110)/8. - (45*p111)/8. + (45*p112)/8. - (15*p113)/8. - (3*p120)/2. + (9*p121)/2. - (9*p122)/2. + (3*p123)/2. + (3*p130)/8. - (9*p131)/8. + (9*p132)/8. - (3*p133)/8. +                 (3*p200)/4. - (9*p201)/4. + (9*p202)/4. - (3*p203)/4. - (15*p210)/8. + (45*p211)/8. - (45*p212)/8. + (15*p213)/8. + (3*p220)/2. - (9*p221)/2. + (9*p222)/2. - (3*p223)/2. - (3*p230)/8. + (9*p231)/8. - (9*p232)/8. +                 (3*p233)/8. - p300/4. + (3*p301)/4. - (3*p302)/4. + p303/4. + (5*p310)/8. - (15*p311)/8. + (15*p312)/8. - (5*p313)/8. - p320/2. + (3*p321)/2. - (3*p322)/2. + p323/2. + p330/8. - (3*p331)/8. + (3*p332)/8. - p333/8.;
        a330 = p001/4. - (3*p011)/4. + (3*p021)/4. - p031/4. - (3*p101)/4. + (9*p111)/4. - (9*p121)/4. + (3*p131)/4. + (3*p201)/4. - (9*p211)/4. + (9*p221)/4. - (3*p231)/4. - p301/4. + (3*p311)/4. - (3*p321)/4. + p331/4.;
        a331 = -p000/8. + p002/8. + (3*p010)/8. - (3*p012)/8. - (3*p020)/8. + (3*p022)/8. + p030/8. - p032/8. + (3*p100)/8. - (3*p102)/8. - (9*p110)/8. + (9*p112)/8. + (9*p120)/8. - (9*p122)/8. - (3*p130)/8. + (3*p132)/8. - (3*p200)/8. +                 (3*p202)/8. + (9*p210)/8. - (9*p212)/8. - (9*p220)/8. + (9*p222)/8. + (3*p230)/8. - (3*p232)/8. + p300/8. - p302/8. - (3*p310)/8. + (3*p312)/8. + (3*p320)/8. - (3*p322)/8. - p330/8. + p332/8.;
        a332 = p000/4. - (5*p001)/8. + p002/2. - p003/8. - (3*p010)/4. + (15*p011)/8. - (3*p012)/2. + (3*p013)/8. + (3*p020)/4. - (15*p021)/8. + (3*p022)/2. - (3*p023)/8. - p030/4. + (5*p031)/8. - p032/2. + p033/8. - (3*p100)/4. +                 (15*p101)/8. - (3*p102)/2. + (3*p103)/8. + (9*p110)/4. - (45*p111)/8. + (9*p112)/2. - (9*p113)/8. - (9*p120)/4. + (45*p121)/8. - (9*p122)/2. + (9*p123)/8. + (3*p130)/4. - (15*p131)/8. + (3*p132)/2. - (3*p133)/8. +                 (3*p200)/4. - (15*p201)/8. + (3*p202)/2. - (3*p203)/8. - (9*p210)/4. + (45*p211)/8. - (9*p212)/2. + (9*p213)/8. + (9*p220)/4. - (45*p221)/8. + (9*p222)/2. - (9*p223)/8. - (3*p230)/4. + (15*p231)/8. - (3*p232)/2. +                 (3*p233)/8. - p300/4. + (5*p301)/8. - p302/2. + p303/8. + (3*p310)/4. - (15*p311)/8. + (3*p312)/2. - (3*p313)/8. - (3*p320)/4. + (15*p321)/8. - (3*p322)/2. + (3*p323)/8. + p330/4. - (5*p331)/8. + p332/2. - p333/8.;
        a333 = -p000/8. + (3*p001)/8. - (3*p002)/8. + p003/8. + (3*p010)/8. - (9*p011)/8. + (9*p012)/8. - (3*p013)/8. - (3*p020)/8. + (9*p021)/8. - (9*p022)/8. + (3*p023)/8. + p030/8. - (3*p031)/8. + (3*p032)/8. - p033/8. + (3*p100)/8. -                 (9*p101)/8. + (9*p102)/8. - (3*p103)/8. - (9*p110)/8. + (27*p111)/8. - (27*p112)/8. + (9*p113)/8. + (9*p120)/8. - (27*p121)/8. + (27*p122)/8. - (9*p123)/8. - (3*p130)/8. + (9*p131)/8. - (9*p132)/8. + (3*p133)/8. -                 (3*p200)/8. + (9*p201)/8. - (9*p202)/8. + (3*p203)/8. + (9*p210)/8. - (27*p211)/8. + (27*p212)/8. - (9*p213)/8. - (9*p220)/8. + (27*p221)/8. - (27*p222)/8. + (9*p223)/8. + (3*p230)/8. - (9*p231)/8. + (9*p232)/8. -                 (3*p233)/8. + p300/8. - (3*p301)/8. + (3*p302)/8. - p303/8. - (3*p310)/8. + (9*p311)/8. - (9*p312)/8. + (3*p313)/8. + (3*p320)/8. - (9*p321)/8. + (9*p322)/8. - (3*p323)/8. - p330/8. + (3*p331)/8. - (3*p332)/8. + p333/8.;
    }

    double t2 = t*t;      double t3 = t*t2;
    double u2 = u*u;      double u3 = u*u2;
    double v2 = v*v;      double v3 = v*v2;

    vec3 gradient;

    gradient.x   = ((a100 + a101*v + a102*v2 + a103*v3) + (a110 + a111*v + a112*v2 + a113*v3)*u + (a120 + a121*v + a122*v2 + a123*v3)*u2 + (a130 + a131*v + a132*v2 + a133*v3)*u3)     +
                 2*((a200 + a201*v + a202*v2 + a203*v3) + (a210 + a211*v + a212*v2 + a213*v3)*u + (a220 + a221*v + a222*v2 + a223*v3)*u2 + (a230 + a231*v + a232*v2 + a233*v3)*u3) * t +
                 3*((a300 + a301*v + a302*v2 + a303*v3) + (a310 + a311*v + a312*v2 + a313*v3)*u + (a320 + a321*v + a322*v2 + a323*v3)*u2 + (a330 + a331*v + a332*v2 + a333*v3)*u3) * t2;

    gradient.y   = ( 0 + (a010 + a011*v + a012*v2 + a013*v3) + 2*(a020 + a021*v + a022*v2 + a023*v3)*u + 3*(a030 + a031*v + a032*v2 + a033*v3)*u2)        +
                   ( 0 + (a110 + a111*v + a112*v2 + a113*v3) + 2*(a120 + a121*v + a122*v2 + a123*v3)*u + 3*(a130 + a131*v + a132*v2 + a133*v3)*u2) * t    +
                   ( 0 + (a210 + a211*v + a212*v2 + a213*v3) + 2*(a220 + a221*v + a222*v2 + a223*v3)*u + 3*(a230 + a231*v + a232*v2 + a233*v3)*u2) * t2   +
                   ( 0 + (a310 + a311*v + a312*v2 + a313*v3) + 2*(a320 + a321*v + a322*v2 + a323*v3)*u + 3*(a330 + a331*v + a332*v2 + a333*v3)*u2) * t3;


    gradient.z   = ((0 + a001 + 2*a002*v + 3*a003*v2) + (0 + a011 + 2*a012*v + 3*a013*v2)*u + (0 + a021 + 2*a022*v + 3*a023*v2)*u2 + (0 + a031 + 2*a032*v + 3*a033*v2)*u3)        +
                   ((0 + a101 + 2*a102*v + 3*a103*v2) + (0 + a111 + 2*a112*v + 3*a113*v2)*u + (0 + a121 + 2*a122*v + 3*a123*v2)*u2 + (0 + a131 + 2*a132*v + 3*a133*v2)*u3) * t    +
                   ((0 + a201 + 2*a202*v + 3*a203*v2) + (0 + a211 + 2*a212*v + 3*a213*v2)*u + (0 + a221 + 2*a222*v + 3*a223*v2)*u2 + (0 + a231 + 2*a232*v + 3*a233*v2)*u3) * t2   +
                   ((0 + a301 + 2*a302*v + 3*a303*v2) + (0 + a311 + 2*a312*v + 3*a313*v2)*u + (0 + a321 + 2*a322*v + 3*a323*v2)*u2 + (0 + a331 + 2*a332*v + 3*a333*v2)*u3) * t3;

    return gradient;
}

template <typename T>
T* ScalarField<T>::data() const
{
    return m_data;
}

template <typename T>
T& ScalarField<T>::data(int i, int j, int k) const
{
    BoundingBox bounds = dataBounds();
    int w = (int)bounds.size.x;
    int h = (int)bounds.size.y;
    int d = (int)bounds.size.z;

    return m_data[k*w*h + j*w + i];
}


template <typename T>
void ScalarField<T>::setBounds(const BoundingBox &bounds)
{
    m_bounds = bounds;
}

template <typename T>
BoundingBox ScalarField<T>::bounds() const
{
    return m_bounds;
}

template <typename T>
BoundingBox ScalarField<T>::dataBounds() const
{
    switch(m_centeringType){
        case CellCentered:
            return BoundingBox(vec3::zero, vec3(m_w, m_h, m_d));
            break;

        case NodeCentered:
            return BoundingBox(vec3::zero, vec3(m_w-1, m_h-1, m_d-1));
            break;

        default:
            std::cerr << "Bad CenterType Defined, Returning empty BoundingBox" << std::endl;
            return BoundingBox(vec3::zero, vec3::zero);
            break;
    }
}

template <typename T>
void ScalarField<T>::setScale(const vec3 &scale)
{
    m_scale = scale;
    m_scaleInv = vec3(1.0/scale.x, 1.0/scale.y, 1.0/scale.z);
    m_bounds.origin = vec3(m_bounds.origin.x*m_scale.x,
                           m_bounds.origin.y*m_scale.y,
                           m_bounds.origin.z*m_scale.z);
    m_bounds.size =    vec3(m_bounds.size.x*m_scale.x,
                            m_bounds.size.y*m_scale.y,
                            m_bounds.size.z*m_scale.z);
}

template <typename T>
const vec3& ScalarField<T>::scale() const
{
    return m_scale;
}

template <typename T>
void ScalarField<T>::setCenterType(CenteringType center)
{
    m_centeringType = center;
}

template <typename T>
CenteringType ScalarField<T>::getCenterType() const
{
    return m_centeringType;
}

template <typename T>
void ScalarField<T>::setData(T *data)
{
    m_data = data;
}

template <typename T>
vec3 ScalarField<T>::gradientAt(double x, double y, double z) const
{
    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered){
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    int i0 = (int)floor(x);   int i1 = i0+1;
    int j0 = (int)floor(y);   int j1 = j0+1;
    int k0 = (int)floor(z);   int k1 = k0+1;


    if(m_centeringType == CellCentered)
    {
        i0 = (int)clamp(i0, 0, m_w-1);
        j0 = (int)clamp(j0, 0, m_h-1);
        k0 = (int)clamp(k0, 0, m_d-1);

        i1 = (int)clamp(i1, 0, m_w-1);
        j1 = (int)clamp(j1, 0, m_h-1);
        k1 = (int)clamp(k1, 0, m_d-1);
    }
    else if(m_centeringType == NodeCentered)
    {
        i0 = clamp(i0, 0, m_w-2);
        j0 = clamp(j0, 0, m_h-2);
        k0 = clamp(k0, 0, m_d-2);

        i1 = clamp(i1, 0, m_w-2);
        j1 = clamp(j1, 0, m_h-2);
        k1 = clamp(k1, 0, m_d-2);
    }


    double C000 = m_data[i0 + j0*m_w + k0*m_w*m_h];
    double C001 = m_data[i0 + j0*m_w + k1*m_w*m_h];
    double C010 = m_data[i0 + j1*m_w + k0*m_w*m_h];
    double C011 = m_data[i0 + j1*m_w + k1*m_w*m_h];
    double C100 = m_data[i1 + j0*m_w + k0*m_w*m_h];
    double C101 = m_data[i1 + j0*m_w + k1*m_w*m_h];
    double C110 = m_data[i1 + j1*m_w + k0*m_w*m_h];
    double C111 = m_data[i1 + j1*m_w + k1*m_w*m_h];



//                  The interpolated function as function of t,u,v

//                ((1-t)*(1-u)*(1-v)*C000 + (1-t)*(1-u)*(v)*C001 +
//                 (1-t)*  (u)*(1-v)*C010 + (1-t)*  (u)*(v)*C011 +
//                 (t)*(1-u)*(1-v)*C100 +   (t)*(1-u)*(v)*C101 +
//                 (t)*  (u)*(1-v)*C110 +   (t)*  (u)*(v)*C111);

    vec3 grad;

    grad.x  = ((-1)*(1-u)*(1-v)*C000 + (-1)*(1-u)*(v)*C001 +
               (-1)*  (u)*(1-v)*C010 + (-1)*  (u)*(v)*C011 +
                (1)*(1-u)*(1-v)*C100 +  (1)*(1-u)*(v)*C101 +
                (1)*  (u)*(1-v)*C110 +  (1)*  (u)*(v)*C111);

    grad.y  = ((1-t)*(-1)*(1-v)*C000 + (1-t)*(-1)*(v)*C001 +
               (1-t)* (1)*(1-v)*C010 + (1-t)* (1)*(v)*C011 +
                 (t)*(-1)*(1-v)*C100 +   (t)*(-1)*(v)*C101 +
                 (t)* (1)*(1-v)*C110 +   (t)* (1)*(v)*C111);

    grad.z  = ((1-t)*(1-u)*(-1)*C000 + (1-t)*(1-u)*(1)*C001 +
               (1-t)*  (u)*(-1)*C010 + (1-t)*  (u)*(1)*C011 +
                 (t)*(1-u)*(-1)*C100 +   (t)*(1-u)*(1)*C101 +
                 (t)*  (u)*(-1)*C110 +   (t)*  (u)*(1)*C111);

    return grad;
}

template <typename T>
vec3 ScalarField<T>::gradientAt(const vec3 &x) const
{
    return gradientAt((double)x.x,(double)x.y,(double)x.z);
}

template <typename T>
vec3 ScalarField<T>::FD_central_gradientAt(double x, double y, double z) const
{
    double h=1e-2;
    double leftval[3], rightval[3], grad[3];

    leftval[0] = valueAt(x-h, y, z);
    rightval[0] = valueAt(x+h, y, z);
    leftval[1] = valueAt(x, y-h, z);
    rightval[1] = valueAt(x, y+h, z);
    leftval[2] = valueAt(x, y, z-h);
    rightval[2] = valueAt(x, y, z+h);

    for(int i=0; i<3; i++)
        grad[i] = (rightval[i]-leftval[i])/(2*h);

    vec3 ret(grad[0],grad[1],grad[2]);

    return ret;
}

template <typename T>
vec3 ScalarField<T>::FD_central_gradientAt(const vec3 &x) const
{
    return FD_central_gradientAt((double)x.x,(double)x.y,(double)x.z);
}

template <typename T>
double ScalarField<T>::convolutionTricubicValueAt(const vec3 &x) const
{
    return convolutionTricubicValueAt(x.x, x.y, x.z);
}

template <typename T>
double ScalarField<T>::convolutionTricubicValueAt(double x, double y, double z) const
{
    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered){
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

//    std::cout<<x<<" "<<y<<" "<<z<<std::endl;

    double t = fmod(x,1.0);
//    double u = fmod(y,1.0f);
//    double v = fmod(z,1.0f);

    int x0[4];//,y0[4],z0[4];
    x0[0] = (int)floor(x)-1;
//    int y0[0] = floor(y)-1;
//    int z0[0] = floor(z)-1;

    for(int i=1; i<4; i++)
    {
        x0[i]=1+x0[i-1];
//        y0[i]=1+y0[i-1];
//        z0[i]=1+z0[i-1];
    }

    double P[4];
    for(int i=0; i<4; i++)
        P[i] = convolutionBicubicValueAt(x0[i],y,z);

    //If boundary issues, recompute their values
    if(x0[1]==0)
        P[0] = P[3] - 3*P[2] + 3*P[1];
    if(x0[2]==m_w-1)
        P[3] = P[0] - 3*P[1] + 3*P[2];

    return convolutionInterpolate(P,t);

}

template <typename T>
double ScalarField<T>::convolutionBicubicValueAt(double x0, double y, double z) const
{
    double u = fmod(y,1.0);
//    double v = fmod(z,1.0f);

    int y0[4];//,z0[4];
    y0[0] = (int)floor(y)-1;
//    z0[0] = floor(z)-1;

    for(int i=1; i<4; i++)
    {
        y0[i]=1+y0[i-1];
//        z0[i]=1+z0[i-1];
    }

    double P[4];
    for(int i=0; i<4; i++)
        P[i] = convolutionCubicValueAt(x0,y0[i],z);

    //If boundary issues, recompute their values
    if(y0[1]==0)
        P[0] = P[3] - 3*P[2] + 3*P[1];
    if(y0[2]==m_h-1)
        P[3] = P[0] - 3*P[1] + 3*P[2];

    return convolutionInterpolate(P,u);

}

template <typename T>
double ScalarField<T>::convolutionCubicValueAt(double x0, double y0, double z) const
{

    double v = fmod(z,1.0);

    int z0[4];
    z0[0] = (int)floor(z)-1;

    for(int i=1; i<4; i++)
    {
        z0[i]=1+z0[i-1];
    }

    //Manage boundary
    if((int)x0 < 0)
        x0 = 0;
    if((int)y0 < 0)
        y0 = 0;
    if(z0[0] < 0)
        z0[0] = 0;
    if(z0[1] < 0)
        z0[0] = 0;


    if((int)x0 >= m_w)
        x0 = m_w-1;
    if((int)y0 >= m_h)
        y0 = m_h-1;
    if(z0[3] >= m_d)
        z0[3] = m_d-1;
    if(z0[2] >= m_d)
        z0[2] = m_d-1;

    double P[4];
    for(int i=0; i<4; i++)
    {
        P[i] = m_data[(int)x0 + (int)y0*m_w + z0[i]*m_w*m_h];
    }

    //If boundary issues, recompute their values
    if(z0[1]==0)
        P[0] = P[3] - 3*P[2] + 3*P[1];
    if(z0[2]==m_d-1)
        P[3] = P[0] - 3*P[1] + 3*P[2];

//    std::cout<<(int)x0<<" "<<(int)y0<<" "<<z0[0]<<std::endl;

    return convolutionInterpolate(P,v);

}

template <typename T>
double ScalarField<T>::convolutionInterpolate(double P[], double t) const
{
    //We assume 0<=t<=1
    double W[4], a = -0.5;

    double s = 1+t;
    W[0] = a*(-4 + s*(8 + s*(-5 + s*1)));
    s = 2-t;
    W[3] = a*(-4 + s*(8 + s*(-5 + s*1)));

    s = t;
    W[1] = 1 + s*s*(-(a+3) + s*(a+2));
    s = 1-t;
    W[2] = 1 + s*s*(-(a+3) + s*(a+2));

    double ret=0;
    for(int i=0; i<4; i++)
        ret+=W[i]*P[i];

    return ret;
}

template <typename T>
double ScalarField<T>::convolve(int m, double x) const
{
    double s = fabs(x + 1 - m), ret, a=-0.5;
    /*if(s>1)
        ret = a*(-4 + s*(8 + s*(-5 + s*1)));
    else
        ret = 1 + s*s*(-(a+3) + s*(a+2));*/

    if(s>1)
        ret = (2-s)*(2-s)*(2-s)/6.0;
    else
        ret = (4 + s*s*(-6 + 3*s))/6.0;

    return ret;
}

template <typename T>
double ScalarField<T>::dconvolve(int m, double x) const
{
    double s = fabs(x + 1 - m), ret, a=-0.5;
    /*if(s>1)
        ret = a*(8 + s*(-10 + s*3));
    else
        ret = s*(-2*(a+3) + s*3*(a+2));*/
    if(s>1)
        ret = -3*(2-s)*(2-s)/6.0;
    else
        ret = s*(-12+9*s)/6.0;

    if(x + 1 - m < 0)
        ret*=-1;

    return ret;
}

template <typename T>
double ScalarField<T>::convolutionValueAt(const vec3 &x) const
{
    return convolutionValueAt(x.x, x.y, x.z);
}

template <typename T>
double ScalarField<T>::convolutionValueAt(double x, double y, double z) const
{
    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered){
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    int x0,y0,z0;
    x0 = (int)floor(x)-1;
    y0 = (int)floor(y)-1;
    z0 = (int)floor(z)-1;

    double P[4][4][4];

    for(int i = x0; i<x0+4; i++)
    {
        for(int j = y0; j<y0+4; j++)
        {
            for(int k = z0; k<z0+4; k++)
            {
                int i0=i,j0=j,k0=k;
                //Manage boundary
                if(i0 < 0)
                    i0 = 0;
                if(j0 < 0)
                    j0 = 0;
                if(k0 < 0)
                    k0 = 0;

                if(i0 >= m_w)
                    i0 = m_w-1;
                if(j0 >= m_h)
                    j0 = m_h-1;
                if(k0 >= m_d)
                    k0 = m_d-1;

                P[i-x0][j-y0][k-z0] = m_data[i0 + j0*m_w + k0*m_w*m_h];
                //std::cout<<i0<<" "<<j0<<" "<<k0<<" "<<m_data[i0 + j0*m_w + k0*m_w*m_h]<<std::endl;
            }
        }
    }

    //If boundary issues, recompute their values
    if(x0+1==0)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[0][i][j] = P[3][i][j] - 3*P[2][i][j] + 3*P[1][i][j];
    }
    if(x0+2==m_w-1)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[3][i][j] = P[0][i][j] - 3*P[1][i][j] + 3*P[2][i][j];
    }

    if(y0+1==0)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][0][j] = P[i][3][j] - 3*P[i][2][j] + 3*P[i][1][j];
    }
    if(y0+2==m_h-1)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][3][j] = P[i][0][j] - 3*P[i][1][j] + 3*P[i][2][j];
    }

    if(z0+1==0)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][j][0] = P[i][j][3] - 3*P[i][j][2] + 3*P[i][j][1];
    }
    if(z0+2==m_d-1)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][j][3] = P[i][j][0] - 3*P[i][j][1] + 3*P[i][j][2];
    }

    double ret=0;
    for(int i=0; i<4; i++)
    {
        for(int j=0; j<4; j++)
        {
            for(int k=0; k<4; k++)
            {
                ret += convolve(i,t)*convolve(j,u)*convolve(k,v)*P[i][j][k];
                //std::cout<<P[i][j][k]<<" ";
            }
            //std::cout<<std::endl;
        }
        //std::cout<<std::endl;
    }
    //std::cout<<ret<<std::endl<<std::endl;


    return ret;

}

template <typename T>
vec3 ScalarField<T>::convolutionGradientAt(const vec3 &x) const
{
    return convolutionGradientAt(x.x, x.y, x.z);
}

template <typename T>
vec3 ScalarField<T>::convolutionGradientAt(double x, double y, double z) const
{
    x = (x - m_bounds.origin.x)*m_scaleInv.x;
    y = (y - m_bounds.origin.y)*m_scaleInv.y;
    z = (z - m_bounds.origin.z)*m_scaleInv.z;

    if(m_centeringType == CellCentered){
        x -= 0.5f;
        y -= 0.5f;
        z -= 0.5f;
    }

    double t = fmod(x,1.0);
    double u = fmod(y,1.0);
    double v = fmod(z,1.0);

    int x0,y0,z0;
    x0 = (int)floor(x)-1;
    y0 = (int)floor(y)-1;
    z0 = (int)floor(z)-1;

    double P[4][4][4];

    for(int i = x0; i<x0+4; i++)
    {
        for(int j = y0; j<y0+4; j++)
        {
            for(int k = z0; k<z0+4; k++)
            {
                int i0=i,j0=j,k0=k;
                //Manage boundary
                if(i0 < 0)
                    i0 = 0;
                if(j0 < 0)
                    j0 = 0;
                if(k0 < 0)
                    k0 = 0;

                if(i0 >= m_w)
                    i0 = m_w-1;
                if(j0 >= m_h)
                    j0 = m_h-1;
                if(k0 >= m_d)
                    k0 = m_d-1;

                P[i-x0][j-y0][k-z0] = m_data[i0 + j0*m_w + k0*m_w*m_h];
                //std::cout<<i0<<" "<<j0<<" "<<k0<<" "<<m_data[i0 + j0*m_w + k0*m_w*m_h]<<std::endl;
            }
        }
    }

    //If boundary issues, recompute their values
    if(x0+1==0)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[0][i][j] = P[3][i][j] - 3*P[2][i][j] + 3*P[1][i][j];
    }
    if(x0+2==m_w-1)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[3][i][j] = P[0][i][j] - 3*P[1][i][j] + 3*P[2][i][j];
    }

    if(y0+1==0)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][0][j] = P[i][3][j] - 3*P[i][2][j] + 3*P[i][1][j];
    }
    if(y0+2==m_h-1)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][3][j] = P[i][0][j] - 3*P[i][1][j] + 3*P[i][2][j];
    }

    if(z0+1==0)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][j][0] = P[i][j][3] - 3*P[i][j][2] + 3*P[i][j][1];
    }
    if(z0+2==m_d-1)
    {
        for(int i=0; i<4; i++)
            for(int j=0; j<4; j++)
                P[i][j][3] = P[i][j][0] - 3*P[i][j][1] + 3*P[i][j][2];
    }

    vec3 ret(0,0,0);
    for(int i=0; i<4; i++)
    {
        for(int j=0; j<4; j++)
        {
            for(int k=0; k<4; k++)
            {
                ret.x += dconvolve(i,t)*convolve(j,u)*convolve(k,v)*P[i][j][k];
                ret.y += convolve(i,t)*dconvolve(j,u)*convolve(k,v)*P[i][j][k];
                ret.z += convolve(i,t)*convolve(j,u)*dconvolve(k,v)*P[i][j][k];
                //std::cout<<P[i][j][k]<<" ";
            }
            //std::cout<<std::endl;
        }
        //std::cout<<std::endl;
    }
    //std::cout<<ret<<std::endl<<std::endl;


    return ret;
}

// explicit instantion of acceptable types
// TODO: find way to hide implementation but allow aribtrary instantion
template class ScalarField<char>;
template class ScalarField<int>;
template class ScalarField<float>;
template class ScalarField<double>;
template class ScalarField<unsigned char>;
template class ScalarField<unsigned int>;

template class ScalarField<long int>;
template class ScalarField<long double>;

}
